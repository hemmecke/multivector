\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{computation related mathematical structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}
In this pamphlet are implementations of various mathematical
structures related to computation. These are:
lambda.spad
ski.spad
For more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/
Tutorial for lambda calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
Tutorial for SKI calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
Tutorial for Intuitionistic Logic
http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/
Tutorial for utilities to coerce between computation domains
http://www.euclideanspace.com/maths/standards/program/mycode/computation/utility/
\end{abstract}
\eject
\tableofcontents
\eject
\section{Intuitionistic Logic}
The intuitionisticLogic domain implements a Heyting algebra implied
by intuitionistic logic similar to boolean algebra.

Intuitionistic or constructive logic is similar to classical logic
but where the law of excluded middle is not used.
\section{Intuitionistic Logic Tutorial}

The intuitionisticLogic domain needs to be installed on your system.
The source code is in a file called computation.spad.pamphlet, which
is available here:

https://github.com/martinbaker/multivector/

Download and compile in the usual way. Make sure it is exposed since
Axiom/FriCAS was started.

(1) -> )library ILOGIC
 
   ILogic is now explicitly exposed in frame frame1 
   ILogic will be automatically loaded when needed from 
      /home/martin/ILOGIC.NRLIB/ILOGIC

Intuitionistic logic has 3 possible values: false, true and unproven.
These can be constructed as follows:

(1) -> logicF()

   (1)  "_|_"
                                                             Type: ILogic
(2) -> logicT()
 
   (2)  "T"
                                                             Type: ILogic
(3) -> logicU()

   (3)  "?"
                                                             Type: ILogic

The inverse of true is not necessarily false and the inverse of false
is not necessarily true. Therefore the inverse of anything is unproven.

(4) -> l:List ILogic := [logicF(),logicT(),logicU()]

 LISP output:
((0 0) (0 1) (0 2))
                                                       Type: List(ILogic)
(5) -> [(~j)::OutputForm for j in l]

   (5)  ["?","?","?"]
                                                   Type: List(OutputForm)

We can print a truth table for 'and' and 'or'. This is the same as
boolean logic for true/false values and extended for the unproven case.

(6) -> matrix[[(k /\ j)::OutputForm for j in l] for k in l]

   (6)

  	_|_ 	T 	?
_|_ 	_|_ 	_|_ 	_|_
T 	_|_ 	T 	?
? 	_|_ 	? 	?

                                                             Type: Symbol
(7) -> matrix[[(k \/ j)::OutputForm for j in l] for k in l]

   (7)

  	_|_ 	T 	?
_|_ 	_|_ 	T 	?
T 	T 	T 	T
? 	? 	T 	?

                                                             Type: Symbol

'implies' produces the following truth table.

(8) -> matrix[[implies(k,j)::OutputForm for j in l] for k in l]

   (8)

  	_|_ 	T 	?
_|_ 	T 	T 	T
T 	_|_ 	T 	?
? 	_|_ 	T 	T

                                                             Type: Symbol

Now that we can do intuitionistic logic with constant values we can
go on to represent theories. We can enter a symbolic value as follows:

(9) -> proposition("p1")   

   (9)  "p1"
                                                             Type: ILogic

When applying a symbolic value, then it may not possible to compress
as a single node, so the result remains as a tree. So (13) can be
reduced to a single value _|_ because the result does not depend
on 'a', however in (12) we cannot reduce to a single value.

(10) -> proposition("a") /\ proposition("b")

   (10)  "(a/\b)"
                                                             Type: ILogic
(11) -> implies(proposition("a"),proposition("b"))

   (11)  "(a->b)"
                                                             Type: ILogic
(12) -> proposition("a") /\ logicT()

   (12)  "(a/\T)"
                                                             Type: ILogic
(13) -> proposition("a") /\ logicF()

   (13)  "_|_"
                                                             Type: ILogic
\section{category ILOGIC ILogic}
<<domain ILOGIC ILogic>>=
)abbrev domain ILOGIC ILogic
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: April 2011
++ Basic Operations: true, false, unproven
++ Related Constructors:
++ Keywords: intuitionisticLogic
++ Description: ILogic is an algebra with 3 values:
++ true, false and unproven
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

ILogic(): Exports == Implementation where

 NNI==> NonNegativeInteger

 Exports == with
  logicT:() -> %
    ++ true is a logical constant.
  logicF:() -> %
    ++ false is a logical constant.
  logicU:() -> %
    ++ false is a logical constant.
  proposition:(s:String) -> %
    ++ Constructs a proposition
  implies: (%, %) -> %
    ++ implies(a,b) returns the logical implication
    ++ of ILogic a and b.
    ++ a is premise, b is conclusion, result is false (contradiction)
    ++ if premise=true and conclusion=false
    ++ does not mean there is a causal connection
  _~: % -> %
    ++ ~(x) returns the logical complement of x.
  _/_\: (a:%, b:%) -> %
    ++ /\ returns the logical `meet', e.g. `and'.
  _\_/: (a:%, b:%) -> %
    ++  \/ returns the logical `join', e.g. `or'.
  redux:(n: %) -> %
    ++ attempt to simplify theory
    ++ apply recusivly to subnodes
    ++ normally this should not be necessary since logic values are
    ++ interpreted when constructed
  "=": (a:%, b:%) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  children:(n: %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  value:(n: %) -> NNI
    ++ returns:
    ++ 0=false
    ++ 1=true
    ++ 2=unproven
    ++ 3=proposition
    ++ 4=compound
  toString: (n: %) -> String
    ++ output
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         const:Record(val:NNI),_
         var:Record(str:String),_
         nd:Record(typ:NNI,c1:%, c2:%)_
         )

  -- Constructs a proposition
  proposition(s:String): % == [[s]]

  -- constructors
  logicT() == [[1::NNI]]
  logicF() == [[0::NNI]]
  logicU() == [[2::NNI]]

  _~ b == [[2::NNI]]

  -- /\ returns the logical `meet', e.g. `and'.
  _/_\(a:%, b:%) ==
    if (a case const) then
      if (a.const.val = 0::NNI) then return [[0::NNI]]
    if (b case const) then
      if (b.const.val = 0::NNI) then return [[0::NNI]]
    if (a case const) and (b case const) then
      if (a.const.val = 2::NNI) then return [[2::NNI]]
      return [[b.const.val]]
    [[1::NNI,a,b]]


  -- \/ returns the logical `join', e.g. `or'.
  _\_/(a:%, b:%) ==
    if (a case const) then
      if (a.const.val = 1::NNI) then return [[1::NNI]]
    if (b case const) then
      if (b.const.val = 1::NNI) then return [[1::NNI]]
    if (a case const) and (b case const) then
      if (a.const.val = 2::NNI) then return [[2::NNI]]
      return [[b.const.val]]
    [[2::NNI,a,b]]

  -- implies(a,b) returns the logical implication
  -- of ILogic a and b.
  -- a is premise, b is conclusion, result is false (contradiction)
  -- if premise=true and conclusion=false
  -- does not mean there is a causal connection
  implies(a:%, b:%) ==
    if (a case const) and (b case const) then
      if (a.const.val = 1::NNI) and (b.const.val = 2::NNI) then return [[2::NNI]]
      if (a.const.val ~= 0::NNI) and (b.const.val = 0::NNI) then return [[0::NNI]]
      return [[1::NNI]]
    [[0::NNI,a,b]]

  -- attempt to simplify theory
  -- apply recusivly to subnodes
  -- normally this should not be necessary since logic values are
  -- interpreted when constructed
  redux(n: %):% ==
    if n case const then
      if (n.const.val = 0::NNI) then return [[0::NNI]]
      if (n.const.val = 1::NNI) then return [[1::NNI]]
      return [[2::NNI]]
    if n case var then
      return n
    if n case nd then
      if n.nd.typ=0::NNI then return implies(n.nd.c1,n.nd.c2)
      if n.nd.typ=1::NNI then return _/_\(n.nd.c1,n.nd.c2)
      if n.nd.typ=2::NNI then return _\_/(n.nd.c1,n.nd.c2)
    n

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n: %):Boolean == (n case var) or (n case const)

  -- returns:
  -- 0=false
  -- 1=true
  -- 2=unproven
  -- 3=proposition
  -- 4=compound
  value(n: %):NNI ==
    if n case const then
      if (n.const.val = 0::NNI) then return 0::NNI
      if (n.const.val = 1::NNI) then return 1::NNI
      return 2::NNI
    if n case var then
      return 3::NNI
    4::NNI

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  children(n: %):List % ==
    if atom?(n) then return []
    [n.nd.c1,n.nd.c2]

  -- returns true (boolean true) if intuitionisticLogic values
  -- are the same. The terms must match exactly not just be
  -- equivalent, that is x /\ 1 is not equal to x
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
    if (a case const) and (b case const) then
      if (a.const.val = 0::NNI) and (b.const.val = 0::NNI) then return true
      if (a.const.val = 1::NNI) and (b.const.val = 1::NNI) then return true
      if (a.const.val = 2::NNI) and (b.const.val = 2::NNI) then return true
      return false
    if (a case var) and (b case var) then
      -- variable node so compare names
      if a.var.str = b.var.str then return true
      return false
    if (a case nd) and (b case nd) then
      -- binary node which has two subnodes c1 and c2
      if (a.nd.typ ~= b.nd.typ) then return false
      if (a.nd.c1 = b.nd.c1) and (a.nd.c2 = b.nd.c2) then return true
      return false
    false

  -- return string representation
  toString(n: %):String ==
    if n case const then
      if (n.const.val = 0::NNI) then return "__|__"
      if (n.const.val = 1::NNI) then return "T"
      return "?"
    if n case var then
      return n.var.str
      --sayTeX$Lisp concat(["toString case i1=",s])
      --sayTeX$Lisp n
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      s1:String := "->"
      if n.nd.typ = 1::NNI then s1:="/\"
      if n.nd.typ = 2::NNI then s1:="\/"
      return concat(["(",toString(n.nd.c1),s1,toString(n.nd.c2),")"])
    "error"

  -- output
  coerce(n: %):OutputForm ==
    toString(n)::OutputForm

@

\section{Untyped Lambda-Calculus}
for more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/

\section{λ-Calculus}

This code implements untyped λ-calculus, in the future I hope to add
 a typed version.

I realise that Axiom/FriCAS already has a way to create anonymous
functions using +-> in a λ-calculus sort of way. But the aim here
is to represent λ-calculus as a pure mathematical structure so that
we can experiment with the properties of this structure without the
messy features that are required for a practical computer language.
I also need a domain structure which is related to SKI combinators
and IntuitionisticLogic domain and can be coerced to and from these
other domain types as demonstrated on this page.

I also realise that this is written in SPAD which is written in Lisp
which is based on λ-Calculus (perhaps it could later be optimised by
having direct calls to Lisp?)

\section{Notation}

Externally a fairly standard notation is used, as would be familiar to
someone using a textbook to study λ-calculus, or as close as we can get
without using unicode. I would like to use the unicode 'λ' symbol to
represent lambda in FriCAS I/O in many cases this would work fine but
there are some consoles and lisps that don't support unicode so, for
now, I have held off doing this for maximum compatibility.

I have therefore used the '\' symbol to stand for λ.

Internally the domain stores bound variables using De Bruijn index, in
most cases this should not concern the user as I/O uses string names
for variables. Converting bound variables internally to index values
means that the same variable name can be used, in different lambda terms,
without ambiguity and without the need for α-substitution.

De Bruijn index which is a integer where

    0=inside current (inner) lambda term
    1= next outer lambda term
    2= next outer and so on
    ...

We will see how this works in the tutorial below.

So internally the λ-calculus is stored as a binary tree structure using
the following syntax:

<term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"

where:

    \ = λ
    n = De Bruijn index which is a integer where, 0=inside inner
        lambda term, 1= next outer lambda term, 2= next outer and so on.
    var = a string representation of variable (this form is used for
          unbound variables)
    brackets can be used around whole terms.

\section{Tutorial}

The Lambda domain needs to be installed on your system. The source
code is in a file called computation.spad.pamphlet, which is available
here:

https://github.com/martinbaker/multivector/

Download and compile in the usual way. Make sure it is exposed since
Axiom/FriCAS was started.

(1) -> )library LAMBDA
 
   Lambda is already explicitly exposed in frame frame1 
   Lambda will be automatically loaded when needed from 
      /home/martin/LAMBDA.NRLIB/LAMBDA

\section{Constructors}

First we can enter some variables, at the moment they are not inside a
λ-term so they can't yet be bound, but later we can put them into a λ-term..

A numeric name is interpreted as a De Bruijn index when put inside a
λ-term, although we don't need this form for I/O unless we are trying
to avoid some ambiguity, because free and bound variables can be
constructed by giving the variable name as a string

A string name will be converted to a De Bruijn index when put inside a
matching λ-term, otherwise it will be interpreted as a free variable.

(1) -> v1 := lambda("x")

   (1)  "x"
                                                             Type: Lambda
(2) -> v2 := lambda("y")

   (2)  "y"
                                                             Type: Lambda
(3) -> v3 := lambda(0)

   (3)  "0"
                                                             Type: Lambda

This can be built up into more complex lambda terms by using compound
terms (as in (4)) and the λ-term itself (as in (5)).

Each λ-term can only have one bound variable, if more than one bound
variable is required then λ-terms can be nested. λ-term requires that
the bound variable be given a name.

(4) -> n1 := lambda(v1,v2)

   (4)  "(x y)"
                                                             Type: Lambda
(5) -> n2 := lambda(n1,"x")

   (5)  "(\x.(x y))"
                                                             Type: Lambda

In (5) 'x' is a the bound variable and so, when the λ-term was created,
this will be converted to De Bruijn index, in (6) we call toString to
see the internal representation:

In (7) we see that when entered as a numeric index the bound variable
will still be displayed as a string.

In (8) and (9) we can see that the 'unbind' function can be used to
unbind the bound variable 'x' that is, although 'x' has the same string
value as the lambda term, it is treated as though it were different. We
can see this because the toString output does not have a index value. In
(10) we call 'bind' to re-bind it.

(6) -> toString(n2)

   (6)  "(\x.(0 y))"
                                                             Type: String
(7) -> n3 := lambda(v3,"x")

   (7)  "(\x.x)"
                                                             Type: Lambda
(8) -> u2 := unbind(n2)

   (8)  "(\x.(x y))"
                                                             Type: Lambda
(9) -> toString(u2)

   (9)  "(\x.(x y))"
                                                             Type: String
(10) -> toString(bind(u2))

   (10)  "(\x.(0 y))"
                                                             Type: String

So we can already construct any type of lambda term, however its a bit tedious
to construct complex lambda terms in this way, an easier way is to use
'parseLambda' to construct the lambda term from a string. Again we can
enter variables as either alpha or numeric characters depending on whether
we want to specify the index value directly or allow the code to generate it.

In (13) we can see the use of numeric terms to avoid the ambiguity caused
by nested λ-terms with the same name.

(11) -> n4 := parseLambda("\x.\y. y x")

   (11)  "(\x.(\y.(x y)))"
                                                             Type: Lambda
(12) -> toString(n4)

   (12)  "(\x.(\y.(0 1)))"
                                                             Type: String
(13) -> n4a := parseLambda("\x.\x. 0 1")

   (13)  "(\x.(\x'.(x x')))"
                                                             Type: Lambda
(14) -> toString(n4a)

   (14)  "(\x.(\x.(0 1)))"
                                                             Type: String
(15) -> unbind(n4a)

   (15)  "(\x.(\x'.(x x)))"
                                                             Type: Lambda

\section{β-substitution}

The command: subst:(n,a,b) substitutes 'a' for 'b' in 'n' as follows:

(16) -> subst(n2,v2,v1)

   (16)  "(\x.(x y))"
                                                             Type: Lambda
(17) -> subst(n2,v1,v2)

   (17)  "(\x.(x x))"
                                                             Type: Lambda

\section{Relationship to Other Domains}

λ-calculus can be coerced to and from SKI combinators. For a tutorial
about how to coerce to/from this algebra see below.


\section{domain LAMBDA Lambda}
<<domain LAMBDA Lambda>>=
)abbrev domain LAMBDA Lambda
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: April 2011
++ Basic Operations: 
++ Related Constructors: 
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
++ An implementation of untyped lambda-calculus

Lambda(): Exports == Implementation where

 NNI==> NonNegativeInteger

 Exports == with
  lambda:(deBruijn:NNI) -> %
    ++ Constructs a reference to a bound variable from its deBruijn
    ++ index
  lambda:(varNme:String) -> %
    ++ Constructs a reference to a free variable from its name
  lambda:(x:%,y:%) -> %
    ++ Constructs a node containing multiple terms
  lambda:(x:%,t1: String) -> %
    ++ Constructs lambda term and bind any variables with the name provided
  parseLambda:(t1: String) -> %
    ++ Constructs nested lambda terms from a string
    ++ notation assumes format like this:
    ++ <term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"
    ++ where:
    ++ \ = lambda (I would like to use unicode lambda symbol but
    ++             I would also like to keep maximum compatibility
    ++             with non-unicode versions of Lisp)
    ++ n = De Bruijn index which is a integer where, 1=inside inner
    ++             lambda term, 2= next outer lambda term, 3= next
    ++             outer and so on.
    ++ brackets can be used around whole terms.
    ++ This requires the user to work out the De Bruijn index values
    ++ perhaps this could be improved later.
  parseTerm:(t1: String) -> %
    ++ parseTerm is used by parseLambda. It would rarely be called
    ++ externally but it is here to allow it to call parseLambda
    ++ that is to allow circular calls
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is free or bound variable
    ++ otherwise return false if this is a compound or lambda definition
  isCompound?:(n: %) -> Boolean
    ++ returns true if this is a compound term containing two nodes
  isLambda?:(n: %) -> Boolean
    ++ returns true if this is a lambda definition
  free?:(n: %) -> Boolean
    ++ if this is a lambda term then is it free, that is does
    ++ its variable appear in its expression
  children:(n: %) -> List %
    ++ returns 2 child nodes if this is a compound term
    ++ returns 1 child node if this is a lamda term
    ++ otherwise returns []
  name:(n: %) -> String
    ++ if this is a lambda term then return the name of the bound variable
  subst:(n: %,a: %,b: %) -> %
    ++ substitution of 'a' for 'b' in 'n'
  bind:(n: %) -> %
    ++ if this is a lambda term then replace string name in sub-nodes
    ++ with De Bruijn index
  unbind:(n: %) -> %
    ++ if this is a lambda term then replace De Bruijn index in sub-nodes
    ++ with string name
  redux:(n: %) -> %
    ++ beta reduction - apply beta reduction recusivly to all subnodes
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be alpha-equivalent to return true
    ++ That is the names, but not the deBruijn index, of the
    ++ bound variables can be different.
    ++ beta-equivalenty is not implemented because it is not decidable.
  toStringConven: (n:%,boundL: List String) -> String
    ++ return string representation using conventional notation, that is
    ++ deBruijn index is replaced by name using String value for bound variables.
    ++ notation assumes association to the left, in the absence of
    ++ brackets, the term to the left binds more tightly than the
    ++ one on the right.
  toString: (n: %) -> String
    ++ return string representation using conventional deBruijn index for
    ++ bound variables.
    ++ notation assumes association to the left, in the absence of
    ++ brackets, the term to the left binds more tightly than the
    ++ one on the right.
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         boundTerm:Record(varBound:NNI),_
         freeTerm:Record(varUnbound:String),_
         compoundTerm:Record(c1:%, c2:%),_
         lambdaTerm:Record(c3:%, nm:String)_
         )

  -- pointer to current position in string when parsing the
  -- string to construct a lambda term.
  -- I am wary of defining a variable outside of a function but
  -- can't find another non-messy way to update it from several
  -- functions. It might be easier if I could return a tuple from
  -- a function like this:
  -- parseTerm(t1: String,pt:NNI): (pt:NNI,%)
  -- Another alternative might be to define a seperate parsing
  -- domain.
  pt:NNI :=0::NNI

  -- Constructs a reference to a bound variable from its deBruijn
  -- index
  lambda(n1:NNI): % == [[n1]]

  -- Constructs a reference to a free variable from its name
  lambda(varNme:String): % == [[varNme]]

  -- Constructs a node containing multiple terms
  lambda(x:%,y:%): % == [[x,y]]

  -- Constructs lambda term and bind any variables with the name provided
  lambda(x:%,t1: String): % ==
    lt:% := [[x,t1]]
    --sayTeX$Lisp concat(["creating lambda(",toString(x),",",t1") giving:",toString(lt)])
    --sayTeX$Lisp concat(["bound ver=",toString(bind(lt))])
    bind(lt)

  -- returns 2 child nodes if this is a compound term
  -- returns 1 child node if this is a lamda term
  -- otherwise returns []
  children(n: %):List % ==
    if atom?(n) then return []
    if n case compoundTerm then
      return [n.compoundTerm.c1,n.compoundTerm.c2]
    if n case lambdaTerm then
      return [n.lambdaTerm.c3]
    []

  -- if this is a lambda term then return the name of the bound variable
  name(n: %):String ==
    if n case lambdaTerm then
      return n.lambdaTerm.nm
    "error"

  parseStringTerm(t1: String):String ==
    vnm:String := ""
    ch := qelt(t1,pt)
    --sayTeX$Lisp concat("st ch=",ch::String)
    while alphanumeric?(ch) repeat
      vnm := concat(vnm,ch)     
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then return vnm
      ch := qelt(t1,pt)
    vnm

  parseFreeTerm(t1: String):% ==
    lambda(parseStringTerm(t1))

  parseLambdaTerm(t1: String):% ==
    ch := qelt(t1,pt)
    if not (ch = char("\")) then 
      error "lambda term must start with \"
      return [[0::NNI]]
    pt := pt + (1::NNI)
    if pt > maxIndex(t1) then
      error "lambda term not complete"
      return [[0::NNI]]
    str := parseStringTerm(t1)
    ch := qelt(t1,pt)
    if not (ch = char(".")) then 
      error "lambda term must have ."
      return [[0::NNI]]
    pt := pt + (1::NNI)
    if pt > maxIndex(t1) then
      error "lambda term must contain something"
      return [[0::NNI]]
    lambda(parseTerm(t1),str)

  parseBracketTerm(t1: String):% ==
    ch := qelt(t1,pt)
    if not (ch = char("(")) then 
      error "bracket term must start with ("
      return [[0::NNI]]
    pt := pt + (1::NNI)
    if pt > maxIndex(t1) then
      error "opening but no closing bracket"
      return [[0::NNI]]
    trm := parseTerm(t1)
    ch := qelt(t1,pt)
    if not (ch = char(")")) then 
      error "can't find closing bracket"
      return [[0::NNI]]
    pt := pt + (1::NNI)
    trm

  parseVariableTerm(t1: String):% ==
    inx:NNI := 0 -- holds De Bruijn index while its being read
    ch := qelt(t1,pt)
    --sayTeX$Lisp concat("pv ch=",ch::String)
    while digit?(ch) repeat
      if ch = char("0") then inx := inx*10
      if ch = char("1") then inx := inx*10 + 1
      if ch = char("2") then inx := inx*10 + 2
      if ch = char("3") then inx := inx*10 + 3
      if ch = char("4") then inx := inx*10 + 4
      if ch = char("5") then inx := inx*10 + 5
      if ch = char("6") then inx := inx*10 + 6
      if ch = char("7") then inx := inx*10 + 7
      if ch = char("8") then inx := inx*10 + 8
      if ch = char("9") then inx := inx*10 + 9
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then return lambda(inx)
      ch := qelt(t1,pt)
    lambda(inx)

  parseTerm(t1: String):% ==
    res:% := [[0::NNI]]
    ch := qelt(t1,pt)
    --sayTeX$Lisp concat("parseTerm ch=",ch::String)
    -- first remove leading spaces
    while ch = char(" ") repeat
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then
        --sayTeX$Lisp concat(["parseTerm(",t1,") 1 giving:",toString(res)])
        return res
      ch := qelt(t1,pt)
    if ch = char("\") then res := parseLambdaTerm(t1)
    if ch = char("(") then res := parseBracketTerm(t1)
    if digit?(ch) then res := parseVariableTerm(t1)
    if alphabetic?(ch) then res := parseFreeTerm(t1)
    -- now check for compound term
    if pt > maxIndex(t1) then
      --sayTeX$Lisp concat(["parseTerm(",t1,") 2 giving:",toString(res)])
      return res
    ch := qelt(t1,pt)
    if ch = char(" ") then
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then
        --sayTeX$Lisp concat(["parseTerm(",t1,") 3 giving:",toString(res)])
        return res
      res := lambda(res,parseTerm(t1))
    --sayTeX$Lisp concat(["parseTerm(",t1,") 4 giving:",toString(res)])
    res

  -- Constructs nested lambda terms from a string
  -- notation assumes format like this:
  -- <term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"
  -- where:
  -- \ = lambda (I would like to use unicode lambda symbol but
  --             I would also like to keep maximum compatibility
  --             with non-unicode versions of Lisp)
  -- n = De Bruijn index which is a integer where, 1=inside inner
  --             lambda term, 2= next outer lambda term, 3= next
  --             outer and so on.
  -- brackets can be used around whole terms.
  -- This requires the user to work out the De Bruijn index values
  -- perhaps this could be improved later.
  parseLambda(t1: String): % ==
    pt := minIndex(t1)::NNI
    tm := parseTerm(t1)
    --sayTeX$Lisp concat(["parseLambda(",t1,") giving:",toString(tm)])
    tm

  -- returns true if this is an atom, that is free or bound variable
  -- otherwise return false if this is a compound or lambda definition
  atom?(n: %):Boolean == (n case boundTerm) or (n case freeTerm)

  -- returns true if this is a compound term containing two nodes
  isCompound?(n: %):Boolean == (n case compoundTerm)

  -- returns true if this is a lambda definition
  isLambda?(n: %):Boolean == (n case lambdaTerm)

  -- does s not appear in n
  freeVariable?(n: %,s:String):Boolean ==
    if n case freeTerm then
      if n.freeTerm.varUnbound=s then return false
    if n case lambdaTerm then
      if not freeVariable?(n.lambdaTerm.c3,s) then return false
    if n case compoundTerm then
      if not freeVariable?(n.compoundTerm.c1,s) or _
         not freeVariable?(n.compoundTerm.c2,s) then return false
    true

  -- return false if any bound terms
  freeVariable?(n: %,i:NNI):Boolean ==
    if n case boundTerm then
      if n.boundTerm.varBound=i then return false
    if n case lambdaTerm then
      if not freeVariable?(n.lambdaTerm.c3,(i+1)::NNI) then return false
    if n case compoundTerm then
      if (not freeVariable?(n.compoundTerm.c1,i)) or _
         (not freeVariable?(n.compoundTerm.c2,i)) then return false
    true

  -- if this is a lambda term then is it free, that is does
  -- its variable appear in its expression
  free?(n: %):Boolean ==
    if n case lambdaTerm then
      s1:String := n.lambdaTerm.nm
      return freeVariable?(n.lambdaTerm.c3,0::NNI)
    sayTeX$Lisp concat("warning free called on non-lambda term",toString(n))
    false

  -- return string representation using conventional notation, that is
  -- deBruijn index is replaced by name using String value for bound variables.
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  toStringConven(n:%,boundL: List String):String ==
    s:String := ""
    --sayTeX$Lisp concat(["toStringConven(",toString(n),")"])
    if n case boundTerm then
      i:NNI := n.boundTerm.varBound + 1
      --sayTeX$Lisp concat(["toStringConven(",toString(n),") i=",string(i)," #boundL=",string(#boundL)])
      if i > 0 and i <= #boundL then return boundL.i
      s := string(n.boundTerm.varBound)
      --sayTeX$Lisp s
    if n case freeTerm then
      s := n.freeTerm.varUnbound
    if n case compoundTerm then
      s := concat(["(",toStringConven(n.compoundTerm.c1,boundL)," ",toStringConven(n.compoundTerm.c2,boundL),")"])
    if n case lambdaTerm then
      -- variable node so print name
      varName:String := n.lambdaTerm.nm
      while member?(varName,boundL) repeat
        varName := concat(varName,"'")
      boundL2: List String := concat(boundL,varName)
      s := concat(["(\",varName,".",toStringConven(n.lambdaTerm.c3,boundL2),")"])
    s

  -- return string representation using conventional deBruijn index for
  -- bound variables.
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  -- boundTerm:Record(varBound:NNI, ck:NNI),
  -- freeTerm:Record(varUnbound:String),_
  -- compoundTerm:Record(c1:%, c2:%),
  -- lambdaTerm:Record(c3:%, nm:String)
  toString(n:%):String ==
    s:String := ""
    if n case boundTerm then
      s := string(n.boundTerm.varBound)
      --sayTeX$Lisp s
    if n case freeTerm then
      s := n.freeTerm.varUnbound
    if n case compoundTerm then
      s := concat(["(",toString(n.compoundTerm.c1)," ",toString(n.compoundTerm.c2),")"])
    if n case lambdaTerm then
      -- variable node so print name
      s := concat(["(\",n.lambdaTerm.nm,".",toString(n.lambdaTerm.c3),")"])
    s

  -- substitution of 'a' for 'b' in 'n'
  subst(n: %,a: %,b: %):% ==
    if n = b then return a
    if (n case compoundTerm) then
      return lambda(subst(n.compoundTerm.c1,a,b),subst(n.compoundTerm.c2,a,b))
    if (n case lambdaTerm) then
      return lambda(subst(n.lambdaTerm.c3,a,b),n.lambdaTerm.nm)
    n

  -- used by bind to replace a given string name in sub-nodes
  -- with De Bruijn index
  bindTerm(n:%,i:NNI,s:String):% ==
    --sayTeX$Lisp concat(["bindTerm(",toString(n)," map:",string(i)," to ",s,")"])
    if n case boundTerm then
      return lambda(n.boundTerm.varBound)
    if n case freeTerm then
      if n.freeTerm.varUnbound=s then
        --sayTeX$Lisp concat(["convert:",s," to ",string(i)])
        return lambda(i)
      return lambda(n.freeTerm.varUnbound)
    if n case lambdaTerm then
      --sayTeX$Lisp concat(["bindTerm generating lambda(",toString(bindTerm(n.lambdaTerm.c3,i+1,s)),",",n.lambdaTerm.nm,")"])
      return [[bindTerm(n.lambdaTerm.c3,i+1,s),n.lambdaTerm.nm]]
    if n case compoundTerm then
      return lambda(bindTerm(n.compoundTerm.c1,i,s),_
                    bindTerm(n.compoundTerm.c2,i,s))
    n

  -- if this is a lambda term then replace string name in sub-nodes
  -- with De Bruijn index
  bind(n: %):% ==
    --sayTeX$Lisp concat(["bind(",toString(n),")"])
    if (n case lambdaTerm) then
      return [[bindTerm(n.lambdaTerm.c3,0,n.lambdaTerm.nm),n.lambdaTerm.nm]]
    n

  -- used by unbind to replace a given De Bruijn index in sub-nodes
  -- with string name
  unbindTerm(n:%,i:NNI,s:String):% ==
    --sayTeX$Lisp concat(["unbindTerm(",toString(n)," map:",string(i)," to ",s,")"])
    if n case boundTerm then
      if n.boundTerm.varBound=i then
        --sayTeX$Lisp concat(["convert:",string(i)," to ",s])
        return lambda(s)
      return lambda(n.boundTerm.varBound)
    if n case freeTerm then
      return lambda(n.freeTerm.varUnbound)
    if n case lambdaTerm then
      --sayTeX$Lisp concat(["unbindTerm generating lambda(",toString(unbindTerm(n.lambdaTerm.c3,i+1,s)),",",n.lambdaTerm.nm,")"])
      return [[unbindTerm(n.lambdaTerm.c3,i+1,s),n.lambdaTerm.nm]]
    if n case compoundTerm then
      return lambda(unbindTerm(n.compoundTerm.c1,i,s),_
                    unbindTerm(n.compoundTerm.c2,i,s))
    n

  -- if this is a lambda term then replace De Bruijn index in sub-nodes
  -- with string name
  unbind(n: %):% ==
    --sayTeX$Lisp concat(["unbind(",toString(n),")"])
    if (n case lambdaTerm) then
      return [[unbindTerm(n.lambdaTerm.c3,0,n.lambdaTerm.nm),n.lambdaTerm.nm]]
    n

  -- beta reduction - apply beta reduction recusivly to all subnodes
  redux(n: %):% ==
    if atom?(n) then return n -- atom cant be reduced
    if n case compoundTerm then
      -- we are looking for a compound term where the first term is
      -- a lambda expression being applied to the second term.
      term1:% := n.compoundTerm.c1
      term2:% := n.compoundTerm.c2
      if isLambda?(term1) then
        -- apply term1 to term2
        boundVarName:String := term1.lambdaTerm.nm
        return subst(term1,term2,lambda(0::NNI))
      return lambda(redux(term1),redux(term2))
    if n case lambdaTerm then
      return lambda(redux(n.lambdaTerm.c3),n.lambdaTerm.nm)
    n

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be alpha-equivalent to return true
  -- That is the names, but not the deBruijn index, of the
  -- bound variables can be different.
  x = y ==
    if (x case boundTerm) and (y case boundTerm) then
      -- boundTerm so compare deBruijn index
      if x.boundTerm.varBound = y.boundTerm.varBound then return true
      return false
    if (x case freeTerm) and (y case freeTerm) then
      -- freeTerm so compare name String
      if x.freeTerm.varUnbound = y.freeTerm.varUnbound then return true
      return false
    if (x case compoundTerm) and (y case compoundTerm) then
      -- compoundTerm so compare both terms
      if (x.compoundTerm.c1 = y.compoundTerm.c1) and_
         (x.compoundTerm.c2 = y.compoundTerm.c2) then return true
      return false
    if (x case lambdaTerm) and (y case lambdaTerm) then
      -- lambdaTerm only compare body not variable name
      if x.lambdaTerm.c3 = y.lambdaTerm.c3 then return true
      return false
    false

  -- output
  coerce(n: %):OutputForm ==
    toStringConven(n,[])::OutputForm
    --toString(n)::OutputForm
@

\section{SKI Combinators}
for more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/

Ski combinators were introduced by Moses Schönfinkel and Haskell
Curry with the aim of eliminating the need for variables in
mathematical logic. It is equivalent to lambda calculus but it
can be used for doing, without variables, anything that would
require variables in other systems.

The structure is a self-modifing binary tree.
\section{Tutorial}
Tutorial

The Ski domain needs to be installed on your system. Download and
compile in the usual way. Make sure it is exposed since
Axiom/FriCAS was started.

)library SKI
 
   Ski is now explicitly exposed in frame frame1 
   Ski will be automatically loaded when needed from 
      /home/martin/SKI.NRLIB/SKI

\section{Constructing SKI combinators}
Constructing SKI combinators

The I, K and S combinators can be constructed by using the I(), K()
and S() functions. Variables (representing functions) can be
constructed by ski("x") where x is the name of the variable.

(1) -> m1 := I()
   (1)  "I"
                                                              Type: Ski
(2) -> m2 := K()
   (2)  "K"
                                                              Type: Ski
(3) -> m3 := S()
   (3)  "S"
                                                              Type: Ski
(4) -> v1 := ski("x")
   (4)  "x"
                                                              Type: Ski

Compound combinators can be constructed by ski(node1,node2) where
node1 and node2 are other combinators. Internally combinators are
stored as a binary tree. The notation assumes association to the
left, in the absence of brackets, the term to the left binds more
tightly than the one on the right. So, in the following, we can
see that:

    * In n2 the second term is an atom so brackets are not required.
    * In n3 the second term is compound so brackets are required.

(5) -> n1 := ski(m1,m2)
   (5)  "IK"
                                                              Type: Ski
(6) -> n2 := ski(n1,m3)
   (6)  "IKS"
                                                              Type: Ski
(7) -> n3 := ski(m3,n1)
   (7)  "S(IK)"
                                                              Type: Ski

In addition, to avoid having to build up this node by node, there is
a quicker way to construct SKI combinators. We can construct the whole
binary tree from a single string using the parseSki constructor as
follows. Again the notation assumes association to the left, in the
absence of brackets, the term to the left binds more tightly than
the one on the right.

(8) -> n4 := parseSki("IKS")
   (8)  "IKS"
                                                              Type: Ski
(9) -> n5 := parseSki("S(IK)")
   (9)  "S(IK)"
                                                              Type: Ski
\section{redux}
redux

Now that we have constructed our SKI combinator we can apply the
combinators using the redux function. This allows us to apply the
self-modifing binary tree.

The first combinator to investigate is 'I'. This is a do nothing combinator:

(10) -> s1 := parseSki("Ix")
   (10)  "Ix"
                                                              Type: Ski
(11) -> redux(s1)
x
   (11)  "x"
                                                              Type: Ski

The next combinator to investigate is 'K'. This removes the final variable:

(12) -> s2 := parseSki("Kxy")
   (12)  "Kxy"
                                                              Type: Ski
(13) -> redux(s2)
x
   (13)  "x"
                                                              Type: Ski

The next combinator to investigate is 'S' This applies the first two
functions to the third:

(14) -> s3 := parseSki("Sxyz")
   (14)  "Sxyz"
                                                              Type: Ski
(15) -> redux(s3)
xz(yz)
   (15)  "xz(yz)"
                                                              Type: Ski
\section{Secondary Combinators}
Secondary Combinators

Any calculation can be done by some combination of K and S. However some
sequences occur frequently so it is worth assigning them special letters:

Operator 	What it does 	SKI equivalent
(normal form)
I 	Identity (leave unchanged) 	I or SKK or SKS
B 	Function composition 	S(KS)K
B' 	Reverse function composition 	 
C 	Swap functions 	S(K(SI))K
K 	Form constant function 	K
S 	Generalized composition 	S
W 	Doubling or diagonalizing 	 

So we can see in the 3 examples below :

    * In 16 that "SKKxy" is equivalent to "xy", that is SKK is identity,
      equivalent to I
    * In 18 that "S(K(SI))Kxy" is equivalent to "yx", so "S(K(SI))K"
      reverses its operands.

(16) -> redux(parseSki("SKKxy"))
Kx(Kx)y
xy
   (16)  "xy"
                                                              Type: Ski
(17) -> redux(parseSki("S(KS)xy"))
KSy(xy)
S(xy)
   (17)  "S(xy)"
                                                              Type: Ski
(18) -> redux(parseSki("S(K(SI))Kxy"))
K(SI)x(Kx)y
Iy(Kxy)
yx
   (18)  "yx"
                                                              Type: Ski
\section{To Do}
Issue 1

Currently this only works with variables, this means that:

    * redux applied to 'SKKxy' gives 'xy'
    * but redux applied to 'SKK' does not give 'I'

That is, I am looking for a way to 'lift' from working in terms
operators acting on variables to working in terms of operators only.

Issue 2

It would be good to be able to use these combinators to operate on
Axiom/FriCAS functions.

\section{domain SKI Ski}
<<domain SKI Ski>>=
)abbrev domain SKI Ski
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: March 2011
++ Basic Operations: 
++ Related Constructors: 
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/

Ski(): Exports == Implementation where

 NNI==> NonNegativeInteger

 Exports == with
  ski:(x:%,y:%) -> %
    ++ Constructs a node combinator over combinators
  ski:(x:%,y:Variable(I)) -> %
    ++ Constructs a node over (node,I)
  ski:(x:%,y:Variable(K)) -> %
    ++ Constructs a node over (node,K)
  ski:(x:%,y:Variable(S)) -> %
    ++ Constructs a node over (node,S)
  ski:(x:Variable(I),y:%) -> %
    ++ Constructs a node over (I,node)
  ski:(x:Variable(K),y:%) -> %
    ++ Constructs a node over (K,node)
  ski:(x:Variable(S),y:%) -> %
    ++ Constructs a node over (S,node)
  ski:(x:Variable(I),y:Variable(I)) -> %
    ++ Constructs a II combinator
  ski:(x:Variable(I),y:Variable(K)) -> %
    ++ Constructs a IK combinator
  ski:(x:Variable(I),y:Variable(S)) -> %
    ++ Constructs a IS combinator
  ski:(x:Variable(K),y:Variable(I)) -> %
    ++ Constructs a KI combinator
  ski:(x:Variable(K),y:Variable(K)) -> %
    ++ Constructs a KK combinator
  ski:(x:Variable(K),y:Variable(S)) -> %
    ++ Constructs a KS combinator
  ski:(x:Variable(S),y:Variable(I)) -> %
    ++ Constructs a SI combinator
  ski:(x:Variable(S),y:Variable(K)) -> %
    ++ Constructs a SK combinator
  ski:(x:Variable(S),y:Variable(S)) -> %
    ++ Constructs a SS combinator
  ski:(t1: String) -> %
    ++ Constructs variable combinator
  I:() -> %
    ++ Constructs a I combinator
  K:() -> %
    ++ Constructs a K combinator
  S:() -> %
    ++ Constructs a S combinator
  parseSki:(t1: String) -> %
    ++ Constructs combinators from a string
  children:(n: %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  isI?:(n: %) -> Boolean
    ++ returns true if this is an I combinator node
  isK?:(n: %) -> Boolean
    ++ returns true if this is a K combinator node
  isS?:(n: %) -> Boolean
    ++ returns true if this is a S combinator node
  name:(n: %) -> String
    ++ returns the name of this variable, if this is not a
    ++ variable then return "_"
  variables:(n: %) -> List String
    ++ returns a list of variable names under this node
  freeVariable?:(n: %,s:String) -> Boolean
    ++ the variable indicated by 's' is free if it does
    ++ not appear in node 'n' or any of its subnodes.
  redux:(n: %) -> %
    ++ weak reduction - apply this combinator to rearange its
    ++ subnodes then apply recusivly to its subnodes
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be equal to return true
    ++ all terms must be exactly equal, not just equivalent, that is
    ++ SKK=I will return false even though 'SKK' and 'I' have the
    ++ same effect
  toString: (n: %) -> String
    ++ output
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         lf:Record(typ:NNI),_
         nd:Record(c1:%, c2:%),_
         vr:Record(s1:String)_
         )

  -- Constructs a node combinator over another combinators
  ski(x:%,y:%): % == [[x,y]]

  -- Constructs a node over (node,I)
  ski(x:%,y:Variable(I)): % == [[x,I()]]

  -- Constructs a node over (node,K)
  ski(x:%,y:Variable(K)): % == [[x,K()]]

  -- Constructs a node over (node,S)
  ski(x:%,y:Variable(S)): % == [[x,S()]]

  -- Constructs a node over (node,I)
  ski(x:Variable(I),y:%): % == [[I(),y]]

  -- Constructs a node over (node,K)
  ski(x:Variable(K),y:%): % == [[K(),y]]

  -- Constructs a node over (node,S)
  ski(x:Variable(S),y:%): % == [[S(),y]]

  -- Constructs a II combinator
  ski(x:Variable(I),y:Variable(I)): % == [[I(),I()]]

  -- Constructs a IK combinator
  ski(x:Variable(I),y:Variable(K)): % == [[I(),K()]]

  -- Constructs a IS combinator
  ski(x:Variable(I),y:Variable(S)): % == [[I(),S()]]

  -- Constructs a KI combinator
  ski(x:Variable(K),y:Variable(I)): % == [[K(),I()]]

  -- Constructs a KK combinator
  ski(x:Variable(K),y:Variable(K)): % == [[K(),K()]]

  -- Constructs a KS combinator
  ski(x:Variable(K),y:Variable(S)): % == [[K(),S()]]

  -- Constructs a SI combinator
  ski(x:Variable(S),y:Variable(I)): % == [[S(),I()]]

  -- Constructs a SK combinator
  ski(x:Variable(S),y:Variable(K)): % == [[S(),K()]]

  -- Constructs a SS combinator
  ski(x:Variable(S),y:Variable(S)): % == [[S(),S()]]

  -- Constructs variable combinator
  ski(t1: String):% ==
    [[t1]]

  -- Constructs a I combinator
  I(): % == [[1::NNI]]

  -- Constructs a K combinator
  K(): % == [[2::NNI]]

  -- Constructs a S combinator
  S(): % == [[3::NNI]]

  -- convert BinaryTree Character node to Ski node
  -- called recursivly on subnodes
  -- used by parseSki
  btc2Ski(btc: BinaryTree Character): % ==
    if leaf?(btc) then
      ch:Character := value(btc)
      if ch = char("I") then
        return [[1::NNI]]
      if ch = char("K") then
        return [[2::NNI]]
      if ch = char("S") then
        return [[3::NNI]]
      return [[ch::String]]
    if not leaf?(btc) then
      return ski(btc2Ski(left(btc)),btc2Ski(right(btc)))
    [[1::NNI]]

  -- Constructs combinators from a string
  -- ski pass required to use ski lift
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  parseSki(t1: String): % ==
    -- first we build chBuffer which holds the characters
    -- from the String and puts them in a tree
    branchStack: Stack BinaryTree Character := empty()
    chBuffer: BinaryTree Character := empty()
    mn := minIndex(t1)
    mx := maxIndex(t1)
    for pt in mn..mx repeat
      ch := qelt(t1,pt)
      if alphanumeric?(ch) then
        if empty?(chBuffer)
          then chBuffer:=binaryTree(ch)
          else chBuffer:=binaryTree(chBuffer,ch,binaryTree(ch))
      if ch = char("(") then
        push!(chBuffer,branchStack)
        chBuffer:= empty()
      if ch = char(")") then
        hold:BinaryTree Character := pop!(branchStack)
        -- if empty?(hold) then sayTeX$Lisp "hold empty"
        -- if empty?(chBuffer) then sayTeX$Lisp "chBuffer empty"
        if empty?(chBuffer)
          then
            chBuffer:=hold
            sayTeX$Lisp "chBuffer empty"
          else
            if not empty?(hold) then
              chBuffer:=binaryTree(hold,ch,chBuffer)
            --sayTeX$Lisp "chbuffer not empty"
    -- sayTeX$Lisp (mathObject2String$Lisp chBuffer)@String
    -- now chBuffer tree is built we can convert this into the ski
    -- structure
    btc2Ski(chBuffer)

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  children(n: %):List % ==
    if atom?(n) then return []
    [n.nd.c1,n.nd.c2]

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n: %):Boolean == (n case lf) or (n case vr)

  -- returns true if this is an I combinator node
  isI?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf.typ = 1 then return true
    false

  -- returns true if this is a K combinator node
  isK?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf.typ = 2 then return true
    false

  -- returns true if this is a S combinator node
  isS?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf.typ = 3 then return true
    false

  -- returns the name of this variable, if this is not a
  -- variable then return "_"
  name(n: %):String ==
    if n case vr then
      return n.vr.s1
    "__"

  -- the variable indicated by 's' is free if it does
  -- not appear in node 'n' or any of its subnodes.
  freeVariable?(n: %,s:String):Boolean ==
    if n case vr then
      if n.vr.s1=s then return false
    if n case nd then
      if not freeVariable?(n.nd.c1,s) or _
         not freeVariable?(n.nd.c2,s) then return false
    true

  -- returns a list of variable names under this node
  variables(n: %):List String ==
    if n case vr then
      return [n.vr.s1]
    if n case nd then
      return concat(variables(n.nd.c1),variables(n.nd.c2))
    []

  -- return string representation
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  toString(n: %):String ==
    s:String := ""
    if n case lf then
      -- leaf node so print I,K or S
      if n.lf.typ = 1 then s := "I"
      if n.lf.typ = 2 then s := "K"
      if n.lf.typ = 3 then s := "S"
      --sayTeX$Lisp concat(["toString case i1=",s])
      --sayTeX$Lisp n
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      if atom?(n.nd.c2) then
        s := concat([s,toString(n.nd.c1),toString(n.nd.c2)])
      else
        s := concat([s,toString(n.nd.c1),"(",toString(n.nd.c2),")"])
    if n case vr then
      -- variable node so print name
      s := n.vr.s1
    s

  -- weak reduction - apply this combinator to rearange its
  -- subnodes then apply recusivly to its subnodes
  redux1(n: %):% ==
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      left := redux1(n.nd.c1)
      right := redux1(n.nd.c2)
      --sayTeX$Lisp concat(["left=",toString(left),_
      --                    " right=",toString(right)])$String
      if isI?(left) then return right
      if not (left case nd) then return ski(left,right)
      leftleft := left.nd.c1
      leftright := left.nd.c2
      --sayTeX$Lisp concat(["leftleft=",toString(leftleft),_
      --                    " leftright=",toString(leftright)])$String
      if isK?(leftleft) then return leftright
      if not (leftleft case nd) then return ski(left,right)
      leftleftleft := leftleft.nd.c1
      leftleftright := leftleft.nd.c2
      --sayTeX$Lisp concat(["leftleftleft=",toString(leftleftleft),_
      --                    " leftleftright=",toString(leftleftright)])$String
      if isS?(leftleftleft) then
        return ski(ski(leftleftright,right),ski(leftright,right))
      return ski(left,right)
    n

  -- weak reduction - apply this combinator to rearange its
  -- subnodes then apply recusivly to its subnodes
  redux(n: %):% ==
    lastResult := [[1::NNI]]
    thisResult := redux1(n)
    triesLeft:NNI := 20::NNI -- limit tries in case of loop
    while (lastResult ~= thisResult) and (triesLeft > (1::NNI)) repeat
      lastResult := thisResult
      thisResult := redux1(lastResult)
      triesLeft := (triesLeft - 1)::NNI
      sayTeX$Lisp toString(lastResult)
    thisResult

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be equal to return true
  -- all terms must be exactly equal, not just equivalent, that is
  -- SKK=I will return false even though 'SKK' and 'I' have the
  -- same effect
  x = y ==
    if (x case lf) and (y case lf) then
      -- leaf node so compare I,K or S
      if x.lf.typ = y.lf.typ then return true
      return false
    if (x case vr) and (y case vr) then
      -- variable node so compare names
      if x.vr.s1 = y.vr.s1 then return true
      return false
    if (x case nd) and (y case nd) then
      -- binary node which has two subnodes c1 and c2
      if (x.nd.c1 = y.nd.c1) and (x.nd.c2 = y.nd.c2) then return true
      return false
    false

  -- output
  coerce(n: %):OutputForm ==
    toString(n)::OutputForm
@

\section{Logic Utility Package}

The compUtil package provides utilities to convert between the computational domains: Lambda, Ski and ILogic.

Both Lambda are Ski are Turing complete and can be coerced to each other. Lambda and Ski are not equal and they are only isomorphic upto beta-equivalence and beta-equivalence is undecidable so there is not a direct correspondance between the nodes in their trees. Also the names of bound variables and other such constructions may be lost in Lambda -> Ski -> Lambda round trip.

An element of ILogic cannot be coerced to the other types. However ILogic can be used to produce a theory which can be concerted to/from the other domains using Curry–Howard isomorphism.
Tutorial

For these coercions to work then all the computational domains need to be installed on your system. The source code is in a file called computation.spad.pamphlet, which is available here:

https://github.com/martinbaker/multivector/

Download and compile in the usual way. Make sure it is exposed since Axiom/FriCAS was started:

(1) -> )library ILOGIC
 
   ILogic is now explicitly exposed in frame frame1 
   ILogic will be automatically loaded when needed from 
      /home/martin/ILOGIC.NRLIB/ILOGIC
(1) -> )library LAMBDA
 
   Lambda is now explicitly exposed in frame frame1 
   Lambda will be automatically loaded when needed from 
      /home/martin/LAMBDA.NRLIB/LAMBDA
(1) -> )library SKI
 
   Ski is now explicitly exposed in frame frame1 
   Ski will be automatically loaded when needed from 
      /home/martin/SKI.NRLIB/SKI
(1) -> )library COMP

   compUtil is now explicitly exposed in frame frame1
   compUtil will be automatically loaded when needed from
      /home/martin/COMP.NRLIB/COMP

\section{SKI combinators to λ functions}

We can then create SKI combinators and convert them to λ functions.

    For a tutorial about working with SKI combinators see this page.
    For a tutorial about working with λ functions see this page.

If the combinators don't have the required parameters then you will get a warning as follows. The code will attempt to add parameters as required but this will not work in complicated situations.

Ideally when working with 'abstract' combinatiors we need to add the required number of parameters, do the convertion then remove the parameters just added.

(1) -> I()::Lambda

warning I does not have a parameter to act on
creating x

   (1)  "(\x.x)"
                                                             Type: Lambda
(2) -> K()::Lambda

warning K does not enough parameters to act on
creating x and y

   (2)  "(\x.(\y.y))"
                                                             Type: Lambda
(3) -> S()::Lambda

warning S does not enough parameters to act on
creating x,y an z

   (3)  "(\x.(\y.(\z.(z (x (y x))))))"
                                                             Type: Lambda

In the following examples the combinators are provided with the reqired parameters. This conversion works by applying the following rules:

    rule SL1: Ski[I] = \x.0
    rule SL2: Ski[K] = \x.\y.1
    rule SL3: Ski[S] = \x.\y.\z.(2 0 (1 0))
    rule SL4: Ski[(E1 E2)] = (Ski[E1] Ski[E2])

So here are some examples:

(4) -> parseSki("Ia")::Lambda                                            
           
util coerce apply rule SL1 in:Ia                                  
           
   (4)  "(\a.a)"                                                  
                                                             Type: Lambda
(5) -> parseSki("Kab")::Lambda
 
util coerce apply rule SL2 in:Kab

   (5)  "(\a.(\b.b))"
                                                             Type: Lambda
(6) -> parseSki("K(a b)c")::Lambda
 
util coerce apply rule SL2 in:K(ab)c

   (6)  "(\a.(\b.(\c.(c b))))"
                                                             Type: Lambda
(7) -> parseSki("Sabc")::Lambda
 
util coerce apply rule SL2 in:Sabc

   (7)  "(\a.(\b.(\c.((c a) (b a)))))"
                                                             Type: Lambda
(8) -> parseSki("S(K(SI))(S(KK)I)")::Lambda
 
warning S does not enough parameters to act on
creating x,y an z
warning K does not enough parameters to act on
creating x and y
warning S does not enough parameters to act on
creating x,y an z
warning I does not have a parameter to act on
creating x
warning S does not enough parameters to act on
creating x,y an z
warning K does not enough parameters to act on
creating x and y
warning K does not enough parameters to act on
creating x and y
warning I does not have a parameter to act on
creating x

   (8)
"(((\x.(\y.(\z.(z (x (y x)))))) ((\x.(\y.y)) ((\x.(\y.(\z.(z (x (y x))))))
(\x.x)))) (((\x.(\y.(\z.(z (x (y x)))))) ((\x.(\y.y)) (\x.(\y.y))))
(\x.x)))"
                                                             Type: Lambda

\section{λ functions to SKI combinators}

We can then create λ functions and convert them to SKI combinators.

    For a tutorial about working with SKI combinators see this page.
    For a tutorial about working with λ functions see this page.

This process is known as abstraction elimination. it is done by applying the following rules until all lambda terms have been eliminated.

    rule LS1: Lam[x] => x
    rule LS2: Lam[(E1 E2)] => (Lam[E1] Lam[E2])
    rule LS3: Lam[\x.E] => (K Lam[E]) (if x does not occur free in E)
    rule LS4: Lam[\x.x] => I
    rule LS5: Lam[\x.\y.E] => Lam[\x.Lam[\y.E]] (if x occurs free in E)
    rule LS6: Lam[\x.(E1 E2)] => (S Lam[\x.E1] Lam[\x.E2])

Here are some examples:

(9) -> parseLambda("x")::Ski
 
util coerce rule LS1 applied to:x giving x

   (9)  "x"
                                                                Type: Ski
(10) -> parseLambda("x y")::Ski
 
util coerce rule LS2 applied to:(x y) giving (x y)
util coerce rule LS1 applied to:x giving x
util coerce rule LS1 applied to:y giving y

   (10)  "xy"
                                                                Type: Ski
(11) -> parseLambda("\x.1")::Ski
 
util coerce rule LS3 applied to:(\x.1) giving K 1
util coerce rule LS1 applied to:1 giving 1

   (11)  "K1"
                                                                Type: Ski
(12) -> parseLambda("\x.0")::Ski
 
util coerce warning could not match any rule to:(\x.0)

   (12)  "I"
                                                                Type: Ski
(13) -> parseLambda("\x.\y.0 1")::Ski
 
util coerce rule LS5 applied to:(\x.(\y.(0 1))) giving \x.(\y.(0 x))
util coerce rule LS6 applied to:(\y.(0 x)) giving S \y.y \y.x
util coerce rule LS1 applied to:y giving y
util coerce rule LS4' applied to: \y.y giving I
util coerce rule LS1 applied to:x giving x
util coerce rule LS3' applied to: \y.x giving K x
util coerce rule LS5' applied to: \x.SI(Kx) giving S \x.SI \x.Kx
util coerce rule LS3' applied to: \x.SI giving K \x.S \x.I
util coerce rule LS5' applied to: \x.Kx giving S \x.K \x.x
util coerce rule LS3' applied to: \x.K giving K K
util coerce rule LS4' applied to: \x.x giving I

   (13)  "S(K(SI))(S(KK)I)"
                                                                Type: Ski

\section{SKI combinators to Intuitionistic Logic}

We can then create SKI combinators and convert them to intuitionistic logic.

    For a tutorial about working with SKI combinators see this page.
    For a tutorial about working with intuitionistic logic see this page.

This is known as the Curry–Howard isomorphism it uses the following rules:

    rule SI1: Ski[Kab] => a -> (b -> a)
    rule SI2: Ski[Sabc] => (a -> (b -> c)) -> ((a -> b) -> (a -> c))
    rule SI3: Ski[a a->b] => b

The last rule is function application (modus ponens). Here are some examples:

(14) -> parseSki("Ia")::ILogic
 
util coerce apply rule SI1 in:Ia
warning I does not have a parameter to act on
creating x

   (14)  "((x->x)->(x->x))"
                                                             Type: ILogic
(15) -> parseSki("Kab")::ILogic
 
util coerce apply rule SI2 in:Kab

   (15)  "(b->(a->b))"
                                                             Type: ILogic
(16) -> parseSki("K(a b)c")::ILogic
 
util coerce apply rule SI2 in:K(ab)c

   (16)  "(c->((a\/b)->c))"
                                                             Type: ILogic
(17) -> parseSki("Sabc")::ILogic
 
util coerce apply rule SI3 in:Sabc

   (17)  "((c->(b->a))->((c->b)->(c->a)))"
                                                             Type: ILogic

\section{package COMP compUtil}
<<package COMP compUtil>>=
)abbrev package COMP compUtil
++ Author: Martin Baker
++ Date Created: April 2011
++ Date Last Updated: April 2011
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/utility/
++ Description:
++ The compUtil package provides utilities to convert between the
++ computational domains: Lambda, Ski and ILogic.
++ Both Lambda are Ski are Turing complete and can be coerced
++ to each other. Lambda and Ski are not equal and they are only
++ isomorphic upto beta-equivalence and beta-equivalence is
++ undecidable so there is not a direct correspondance
++ between the nodes in their trees.
++ Also the names of bound variables and other such constructions
++ may be lost in Lambda -> Ski -> Lambda round trip.
++ An element of ILogic cannot be coerced to the other types.
++ However ILogic can be used to produce a theory which can
++ be concerted to/from the other domains using Curry–Howard
++ isomorphism.

compUtil(): Exports == Implementation where

 NNI==> NonNegativeInteger
 Exports ==> with
    coerce: (s: Ski) -> Lambda
      ++ coerce SKI combinators to Lambda term.
      ++ this conversion is done by applying the following rules
      ++ rule SL1: Ski[I] = \x.0
      ++ rule SL2: Ski[K] = \x.\y.1
      ++ rule SL3: Ski[S] = \x.\y.\z.(2 0 (1 0))
      ++ rule SL4: Ski[(E1 E2)] = (Ski[E1] Ski[E2])
    coerce: (lam: Lambda) -> Ski
      ++ coerce Lambda term to SKI combinators.
      ++ this process is known as abstraction elimination.
      ++ it is done by applying the following rules until
      ++ all lambda terms have been eliminated.
      ++ rule LS1: Lam[x] => x
      ++ rule LS2: Lam[(E1 E2)] => (Lam[E1] Lam[E2])
      ++ rule LS3: Lam[\x.E] => (K Lam[E]) (if x does not occur free in E)
      ++ rule LS4: Lam[\x.x] => I
      ++ rule LS5: Lam[\x.\y.E] => Lam[\x.Lam[\y.E]] (if x occurs free in E)
      ++ rule LS6: Lam[\x.(E1 E2)] => (S Lam[\x.E1] Lam[\x.E2])
    coerce: (s: Ski) -> ILogic
      ++ coerce combinators to intuitionistic logic
      ++ this is known as the Curry–Howard isomorphism
      ++ it uses the following rules:
      ++ rule SI1: Ski[Kab] => a -> (b -> a),
      ++ rule SI2: Ski[Sabc] => (a -> (b -> c)) -> ((a -> b) -> (a -> c)),
      ++ rule SI3: Ski[a a->b] => b
      ++ the last rule is function application (modus ponens)

 Implementation ==> add

  DeBruijn(name: String,var: List String):NNI ==
    for i in 1..(#var) repeat
      --sayTeX$Lisp concat(["i=",string(i)])$String
      if name = var.i then return (i-1)::NNI
    0::NNI

  -- used by coerce SKI combinators to Lambda term.
  Ski2Lambda(s: Ski,var: List String):Lambda ==
    -- if s is an atom then this means that there are no
    -- parameters for this combinator. If there had been
    -- they would have been found when this was called on
    -- the nodes above it.
    -- I don't know the best way to hanle this, really we
    -- need to add the required number of parameters, do
    -- the convertion then remove the parameters just added.
    -- sayTeX$Lisp concat(["util coerce called for:",toString(s)])$String
    if atom?(s) then
      --sayTeX$Lisp concat(["util coerce atom:",toString(s)])$String
      if isI?(s) then
        sayTeX$Lisp "warning I does not have a parameter to act on"
        sayTeX$Lisp "creating x"
        return parseLambda("\x.0")
      if isK?(s) then
        sayTeX$Lisp "warning K does not enough parameters to act on"
        sayTeX$Lisp "creating x and y"
        return parseLambda("\x.\y.1")
      if isS?(s) then
        sayTeX$Lisp "warning S does not enough parameters to act on"
        sayTeX$Lisp "creating x,y an z"
        return parseLambda("\x.\y.\z.2 0 (1 0)")
      return lambda(DeBruijn(name(s),var))
    subnodes:List Ski := children(s)
    c1:Ski := first subnodes
    c2:Ski := second subnodes
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)," c2=",toString(c2)])$String
    -- look for I x, if found translate x
    if isI?(c1) then
      sayTeX$Lisp concat(["util coerce apply rule SL1 in:",toString(s)])$String
      return Ski2Lambda(c2,var)
    if atom?(c1) then return lambda(Ski2Lambda(c1,var),Ski2Lambda(c2,var))
    -- look for K x y, if found translate x
    subsubnodes:List Ski := children(c1)
    c11:Ski := first subsubnodes
    c12:Ski := second subsubnodes
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)," c2=",toString(c2)," c11=",toString(c11)," c12=",toString(c12)])$String
    if isK?(c11) then
      s2:String := name(c12)
      sayTeX$Lisp concat(["util coerce apply rule SL2 in:",toString(s)])$String
      return Ski2Lambda(c12,var)
    if atom?(c11) then return lambda(Ski2Lambda(c1,var),Ski2Lambda(c2,var))
    -- look for S x y z, if found translate (x z)(y z)
    subsubnodes2:List Ski := children(c11)
    c111:Ski := first subsubnodes2
    c112:Ski := second subsubnodes2
    --sayTeX$Lisp concat(["util coerce c11=",toString(c11)," c12=",toString(c12)," c111=",toString(c111)," c112=",toString(c112)])$String
    -- look for K x y, if found translate x
    if isS?(c111) then
      s2:String := name(c2)
      s12:String := name(c12)
      s112:String := name(c112)
      sayTeX$Lisp concat(["util coerce apply rule SL2 in:",toString(s)])$String
      return lambda(lambda(Ski2Lambda(c112,var),Ski2Lambda(c2,var)),lambda(Ski2Lambda(c12,var),Ski2Lambda(c2,var)))
    lambda(Ski2Lambda(c1,var),Ski2Lambda(c2,var))

  -- coerce SKI combinators to Lambda term.
  -- this conversion is done by applying the following rules
  -- rule SL1: Ski[I] = \x.0
  -- rule SL2: Ski[K] = \x.\y.1
  -- rule SL3: Ski[S] = \x.\y.\z.(2 0 (1 0))
  -- rule SL4: Ski[(E1 E2)] = (Ski[E1] Ski[E2])
  coerce(s: Ski):Lambda ==
    var: List String := reverse variables(s)
    -- first calculate expression
    term:Lambda := Ski2Lambda(s,var)
    -- then bind variables
    for t in var repeat
      term := lambda(term,t)
    term

  -- when we are coerceing Lambda to Ski and we apply rule LS5
  -- we call this
  lambdaOverSki(var:String,sk:Ski):Ski ==
    --sayTeX$Lisp concat(["gives \",var,".",toString(sk)])$String
    if atom?(sk) then
      if freeVariable?(sk,var) then
        sayTeX$Lisp concat(["util coerce rule LS3' applied to: \",var,".",toString(sk)," giving K ",toString(sk)])$String
        return ski(K(),sk)
      sayTeX$Lisp concat(["util coerce rule LS4' applied to: \",var,".",toString(sk)," giving I"])$String
      return I()
    ch: List Ski := children(sk)
    left:Ski := first ch
    right:Ski := second ch
    --sayTeX$Lisp concat(["left=",toString(left),_
    --                    " right=",toString(right)])$String
    if freeVariable?(sk,var) then
      sayTeX$Lisp concat(["util coerce rule LS3' applied to: \",var,".",toString(sk)," giving K \",var,".",toString(left)," \",var,".",toString(right)])$String
      --return ski(ski(K(),left),right)
      return ski(K(),ski(left,right))
    sayTeX$Lisp concat(["util coerce rule LS5' applied to: \",var,".",toString(sk)," giving S \",var,".",toString(left)," \",var,".",toString(right)])$String
    return ski(ski(S(),lambdaOverSki(var,left)),lambdaOverSki(var,right))

  -- coerce Lambda term to SKI combinators.
  -- this process is known as abstraction elimination.
  -- it is done by applying the following rules until
  -- all lambda terms have been eliminated.
  -- rule LS1: Lam[x] => x
  -- rule LS2: Lam[(E1 E2)] => (Lam[E1] Lam[E2])
  -- rule LS3: Lam[\x.E] => (K Lam[E]) (if x does not occur free in E)
  -- rule LS4: Lam[\x.x] => I
  -- rule LS5: Lam[\x.\y.E] => Lam[\x.Lam[\y.E]] (if x occurs free in E)
  -- rule LS6: Lam[\x.(E1 E2)] => (S Lam[\x.E1] Lam[\x.E2])
  coerce(lam: Lambda):Ski ==
    -- test for rule 1
    if atom?(lam) then
      sayTeX$Lisp concat(["util coerce rule LS1 applied to:",toString(lam)," giving ",toString(lam)])$String
      return ski(toString(lam))
    if isCompound?(lam) then
      ch:List Lambda := children(lam)
      c1:Lambda := first ch
      c2:Lambda := second ch
      sayTeX$Lisp concat(["util coerce rule LS2 applied to:",toString(lam)," giving (",toString(c1)," ",toString(c2),")"])$String
      return ski(c1::Ski,c2::Ski)
    if isLambda?(lam) then
      lamUn:Lambda := unbind(lam)
      c3:Lambda := first children(lamUn)
      s3:String := name(lam)
      if atom?(c3) then
        if toString(c3)="0" then
          sayTeX$Lisp concat(["util coerce rule LS4 applied to:",toString(lam)," giving I"])$String
          return I()
      if free?(lam) then
        sayTeX$Lisp concat(["util coerce rule LS3 applied to:",toString(lam)," giving K ",toString(c3)])$String
        return ski(K(),c3::Ski)
      if isLambda?(c3) then
        c33:Lambda := first children(c3)
        cxx:Lambda := lambda(c33,name(c3))
        sayTeX$Lisp concat(["util coerce rule LS5 applied to:",toString(lam)," giving \",s3,".",toString(cxx)])$String
        return lambdaOverSki(s3,cxx::Ski)
      if isCompound?(c3) then
        ch3:List Lambda := children(c3)
        c31:Lambda := first ch3
        c32:Lambda := second ch3
        sayTeX$Lisp concat(["util coerce rule LS6 applied to:",toString(lam)," giving S \",s3,".",toString(c31)," \",s3,".",toString(c32)])$String
        return ski(ski(S(),lambdaOverSki(s3,c31::Ski)),lambdaOverSki(s3,c32::Ski))
    sayTeX$Lisp concat(["util coerce warning could not match any rule to:",toString(lam)])$String
    I()

  -- coerce combinators to intuitionistic logic
  -- this is known as the Curry–Howard isomorphism
  -- it uses the following rules:
  -- rule SI1: Ski[Ia] => a -> a,
  -- rule SI2: Ski[Kab] => a -> (b -> a),
  -- rule SI3: Ski[Sabc] => (a -> (b -> c)) -> ((a -> b) -> (a -> c)),
  -- rule SI4: Ski[a a->b] => b
  -- the last rule is function application (modus ponens)
  coerce(s: Ski):ILogic ==
    -- if s is an atom then this means that there are no
    -- parameters for this combinator. If there had been
    -- they would have been found when this was called on
    -- the nodes above it.
    -- I don't know the best way to hanle this, really we
    -- need to add the required number of parameters, do
    -- the convertion then remove the parameters just added.
    -- sayTeX$Lisp concat(["util coerce called for:",toString(s)])$String
    if atom?(s) then
      --sayTeX$Lisp concat(["util coerce atom:",toString(s)])$String
      if isI?(s) then
        sayTeX$Lisp "warning I does not have a parameter to act on"
        sayTeX$Lisp "creating x"
        a :ILogic  := proposition("x")
        return implies(a,a)
      if isK?(s) then
        sayTeX$Lisp "warning K does not enough parameters to act on"
        sayTeX$Lisp "creating x and y"
        a :ILogic  := proposition("x")
        b :ILogic  := proposition("y")
        return implies(a,implies(b,a))
      if isS?(s) then
        sayTeX$Lisp "warning S does not enough parameters to act on"
        sayTeX$Lisp "creating x,y an z"
        a :ILogic  := proposition("x")
        b :ILogic  := proposition("y")
        c :ILogic  := proposition("z")
        ab :ILogic  := implies(a,b)
        ac :ILogic  := implies(a,c)
        bc :ILogic  := implies(b,c)
        return implies(implies(a,bc),implies(ab,ac))
      return proposition(name(s))
    subnodes:List Ski := children(s)
    c1:Ski := first subnodes
    c2:Ski := second subnodes
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)," c2=",toString(c2)])$String
    -- look for I x, if found translate x
    if isI?(c1) then
      sayTeX$Lisp concat(["util coerce apply rule SI1 in:",toString(s)])$String
      a :ILogic  := c1::ILogic
      return implies(a,a)
    if atom?(c1) then return _\_/(c1::ILogic,c2::ILogic)
    -- look for K x y, if found translate x
    subsubnodes:List Ski := children(c1)
    c11:Ski := first subsubnodes
    c12:Ski := second subsubnodes
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)," c2=",toString(c2)," c11=",toString(c11)," c12=",toString(c12)])$String
    if isK?(c11) then
      sayTeX$Lisp concat(["util coerce apply rule SI2 in:",toString(s)])$String
      a :ILogic  := c2::ILogic
      b :ILogic  := c12::ILogic
      return implies(a,implies(b,a))
    if atom?(c11) then return _\_/(c1::ILogic,c2::ILogic)
    -- look for S x y z, if found translate (x z)(y z)
    subsubnodes2:List Ski := children(c11)
    c111:Ski := first subsubnodes2
    c112:Ski := second subsubnodes2
    --sayTeX$Lisp concat(["util coerce c11=",toString(c11)," c12=",toString(c12)," c111=",toString(c111)," c112=",toString(c112)])$String
    -- look for K x y, if found translate x
    if isS?(c111) then
      sayTeX$Lisp concat(["util coerce apply rule SI3 in:",toString(s)])$String
      a :ILogic  := c2::ILogic
      b :ILogic  := c12::ILogic
      c :ILogic  := c112::ILogic
      ab :ILogic  := implies(a,b)
      ac :ILogic  := implies(a,c)
      bc :ILogic  := implies(b,c)
      return implies(implies(a,bc),implies(ab,ac))
    _\_/(c1::ILogic,c2::ILogic)

@

\section{License}
<<license>>=
--Copyright (c) 2011, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>
@
\eject
\begin{thebibliography}{99}
For more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/
Tutorial for lambda calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
Tutorial for SKI calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
Tutorial for Intuitionistic Logic
http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/
Tutorial for utilities to coerce between computation domains
http://www.euclideanspace.com/maths/standards/program/mycode/computation/utility/
\end{thebibliography}
\end{document}
