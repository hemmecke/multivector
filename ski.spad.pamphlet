\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{computation related mathematical structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}
In this pamphlet are implementations of various mathematical
structures related to computation. These are:
lambda.spad
ski.spad
For more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/
Tutorial for lambda calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
Tutorial for SKI calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
\end{abstract}
\eject
\tableofcontents
\eject
\section{Intuitionistic Logic}
The intuitionisticLogic domain implements a Heyting algebra implied
by intuitionistic logic similar to boolean algebra.

Intuitionistic or constructive logic is similar to classical logic
but where the law of excluded middle is not used.
\section{Intuitionistic Logic Tutorial}

The intuitionisticLogic domain needs to be installed on your system.

Download and compile in the usual way. Make sure it is exposed since
Axiom/FriCAS was started.

(1) -> )library ILOGIC
 
   ILogic is now explicitly exposed in frame frame1 
   ILogic will be automatically loaded when needed from 
      /home/martin/ILOGIC.NRLIB/ILOGIC

Intuitionistic logic has 3 possible values: false, true and unproven.
These can be constructed as follows:

(1) -> logic0()

   (1)  false
                                                             Type: ILogic
(2) -> logic1()

   (2)  true
                                                             Type: ILogic
(3) -> logic2()

   (3)  unproven
                                                             Type: ILogic

The inverse of true is not necessarily false and the inverse of false
is not necessarily true. Therefore the inverse of anything is unproven.

(4) -> l:List ILogic := [logic0(),logic1(),logic2()]

 LISP output:
((0) (1) (2))
                                                       Type: List(ILogic)
(5) -> [(~j)::OutputForm for j in l]

   (5)  [unproven,unproven,unproven]
                                                   Type: List(OutputForm)

We can print a truth table for 'and' and 'or'. This is the same as
boolean logic for true/false values and extended for the unproven case.

(6) -> matrix[[(k /\ j)::OutputForm for j in l] for k in l]

   (6)

  	false 	true 	unproven
false 	false 	false 	false
true 	false 	true 	unproven
unproven 	false 	unproven 	unproven

                                                             Type: Symbol
(7) -> matrix[[(k \/ j)::OutputForm for j in l] for k in l]

   (7)

  	false 	true 	unproven
false 	false 	true 	unproven
true 	true 	true 	true
unproven 	unproven 	true 	unproven

                                                             Type: Symbol

'implies' produces the following truth table.

(8) -> matrix[[implies(k,j)::OutputForm for j in l] for k in l]

   (8)

  	false 	true 	unproven
false 	true 	true 	true
true 	false 	true 	unproven
unproven 	false 	true 	true

                                                             Type: Symbol
\section{category ILOGIC ILogic}
<<domain ILOGIC ILogic>>=
)abbrev domain ILOGIC ILogic
++ Author: Martin Baker
++ Date Created:
++ Change History:
++ Basic Operations: true, false, unproven
++ Related Constructors:
++ Keywords: intuitionisticLogic
++ Description: ILogic is an algebra with 3 values:
++ true, false and unproven
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

ILogic(): Exports == Implementation where

 NNI==> NonNegativeInteger

 Exports == with
  logic1:() -> %
    ++ true is a logical constant.
  logic0:() -> %
    ++ false is a logical constant.
  logic2:() -> %
    ++ false is a logical constant.
  implies: (%, %) -> %
    ++ implies(a,b) returns the logical implication
    ++ of ILogic a and b.
  _~: % -> %
    ++ ~(x) returns the logical complement of x.
  _/_\: (%, %) -> %
    ++ /\ returns the logical `meet', e.g. `and'.
  _\_/: (%, %) -> %
    ++  \/ returns the logical `join', e.g. `or'.
  "=": (%, %) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Record(val:NNI)

  -- constructors
  logic1() == [1::NNI]
  logic0() == [0::NNI]
  logic2() == [2::NNI]

  _~ b == [2::NNI]

  -- /\ returns the logical `meet', e.g. `and'.
  _/_\(a, b) ==
    (a.val = 0::NNI) => [0::NNI]
    (b.val = 0::NNI) => [0::NNI]
    (a.val = 2::NNI) => [2::NNI]
    [b.val]

  -- \/ returns the logical `join', e.g. `or'.
  _\_/(a, b) ==
    (a.val = 1::NNI) => [1::NNI]
    (b.val = 1::NNI) => [1::NNI]
    (a.val = 2::NNI) => [2::NNI]
    [b.val]

  -- implies(a,b) returns the logical implication
  -- of ILogic a and b.
  implies(a, b) ==
    (a.val = 1::NNI) and (b.val = 2::NNI) => [2::NNI]
    (a.val ~= 0::NNI) and (b.val = 0::NNI) => [0::NNI]
    [1::NNI]

  -- returns true (boolean true) if intuitionisticLogic values
  -- are the same.
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
    (a.val = 0::NNI) and (b.val = 0::NNI) => true
    (a.val = 1::NNI) and (b.val = 1::NNI) => true
    (a.val = 2::NNI) and (b.val = 2::NNI) => true
    false

  coerce(x:%):OutputForm ==
    if x.val=0 then return "false"::OutputForm
    if x.val=1 then return "true"::OutputForm
    "unproven"::OutputForm

@
\section{Untyped Lambda-Calculus}
for more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/

First I need to clarify a few issues:

Notation Issue - I would like to use the unicode 'λ' symbol to
represent lambda in FriCAS I/O in many cases this would work fine
but there are some consoles and lisps that don't support unicode so,
for now, I have held off doing this for maximum compatibilty.

I have therefore used the '\' symbol to stand for λ.
I realise that Axiom/FriCAS already has a way to create anonymous
functions using +-> in a λ-calculus sort of way. But the aim here
is to have a domain structure which is related to SKI combinators
and IntuitionisticLogic domain and can be coerced to and from these
other domain types. I also realise that this is written in SPAD which
is written in Lisp which is based on λ-Calculus (perhaps it could be
optimised by having direct calls to Lisp?)

Currently bound variabled use a form of De Bruijn index instead of
usual notation (both for I/O and internal representation). It would
be better to use usual notation for I/O even if it is converted to
De Bruijn index internally.

This is stored as a binary tree structure like this:

<term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"

where:

    * \ = lambda
    * n = De Bruijn index which is a integer where, 0=inside inner
      lambda term, 1= next outer lambda term, 2= next outer and so on.
    * brackets can be used around whole terms.
    * This requires the user to work out the De Bruijn index values
      perhaps this could be improved later.

\section{Untyped Lambda-Calculus Tutorial}

The Lambda domain needs to be installed on your system.

Download and compile in the usual way. Make sure it is exposed since
Axiom/FriCAS was started.

(1) -> )library LAMBDA
 
   Lambda is already explicitly exposed in frame frame1 
   Lambda will be automatically loaded when needed from 
      /home/martin/LAMBDA.NRLIB/LAMBDA

Free and bound variables can be constructed by giving the variable
name as a string. A numeric name is interpreted as a De Bruijn index.
At the moment the code requires that, for bound variables, De Bruijn
index is always used. In future this may be changed to use De Bruijn
index internally but to convert to more conventional notation for
Input/Output.

De Bruijn index which is a integer where

    * 0=inside current (inner) lambda term
    * 1= next outer lambda term
    * 2= next outer and so on
    * ...

Use of De Bruijn index avoids too much overhead in doing α-substitution.

(1) -> v1 := lambda("1")

   (1)  "1"
                                                             Type: Lambda
(2) -> v2 := lambda("x")

   (2)  "x"
                                                             Type: Lambda

\section{Constructors}

This can be built up into more complex lambda terms by using
compound terms (as in (3)) and the λ-term itself (as in (4)).

Each λ-term can only have one bound variable, if more than one
bound variable is required then λ-terms can be nested. λ-term
requires that the bound variable be given a name, even though
this is not strictly nessesary when using De Bruijn index, this
is so we can move to a more conventional notation in the future.

(3) -> n1 := lambda(v1,v2)

   (3)  "(1 x)"
                                                             Type: Lambda
(4) -> n2 := lambda(n1,"x")

   (4)  "(\x.(1 x))"
                                                             Type: Lambda

So far we have enough to constuct any type of lambda term. However
it might be a bit tedous to construct complex lambda terms in this
way, an easier way is to use 'parseLambda' to construct the lambda
term from a string:

(5) -> n3 := parseLambda("(\x.0 y) z")

   (5)  "((\x.(0 y)) z)"
                                                             Type: Lambda

\section{β-substitution}

The command: subst:(n,a,b) substitutes 'a' for 'b' in 'n' as follows:

(6) -> subst(n2,v2,v1)

   (6)  "(\x.(x x))"
                                                             Type: Lambda
(7) -> subst(n2,v1,v2)

   (7)  "(\x.(1 1))"
                                                             Type: Lambda

\section{Evaluating}

We can evaluate the lambda term by using the redux command:

(8) -> redux(n3)

   (8)  "(\x.(z y))"
                                                             Type: Lambda

<<domain LAMBDA Lambda>>=
)abbrev domain LAMBDA Lambda
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: March 2011
++ Basic Operations: 
++ Related Constructors: 
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
++ An implementation of untyped lambda-calculus

Lambda(): Exports == Implementation where

 NNI==> NonNegativeInteger

 Exports == with
  lambda:(deBruijn:NNI) -> %
    ++ Constructs a reference to a bound variable from its deBruijn
    ++ index
  lambda:(varNme:String) -> %
    ++ Constructs a reference to a free variable from its name
  lambda:(x:%,y:%) -> %
    ++ Constructs a node containing multiple terms
  lambda:(x:%,t1: String) -> %
    ++ Constructs lambda term
  parseLambda:(t1: String) -> %
    ++ Constructs nested lambda terms from a string
    ++ notation assumes format like this:
    ++ <term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"
    ++ where:
    ++ \ = lambda (I would like to use unicode lambda symbol but
    ++             I would also like to keep maximum compatibility
    ++             with non-unicode versions of Lisp)
    ++ n = De Bruijn index which is a integer where, 1=inside inner
    ++             lambda term, 2= next outer lambda term, 3= next
    ++             outer and so on.
    ++ brackets can be used around whole terms.
    ++ This requires the user to work out the De Bruijn index values
    ++ perhaps this could be improved later.
  parseTerm:(t1: String) -> %
    ++ parseTerm is used by parseLambda. It would rarely be called
    ++ externally but it is here to allow it to call parseLambda
    ++ that is to allow circular calls
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is free or bound variable
    ++ otherwise return false if this is a compound or lambda definition
  isCompound?:(n: %) -> Boolean
    ++ returns true if this is a compound term containing two nodes
  isLambda?:(n: %) -> Boolean
    ++ returns true if this is a lambda definition
  subst:(n: %,a: %,b: %) -> %
    ++ substitution of 'a' for 'b' in 'n'
  redux:(n: %) -> %
    ++ beta reduction - apply beta reduction recusivly to all subnodes
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be alpha-equivalent to return true
    ++ That is the names, but not the deBruijn index, of the
    ++ bound variables can be different.
  toString: (n: %) -> String
    ++ output
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         boundTerm:Record(deBruijn:NNI),_
         freeTerm:Record(varName:String),_
         compoundTerm:Record(c1:%, c2:%),_
         lambdaTerm:Record(c3:%, nm:String)_
         )

  -- pointer to current position in string when parsing the
  -- string to construct a lambda term.
  -- I am wary of defining a variable outside of a function but
  -- can't find another non-messy way to update it from several
  -- functions. It might be easier if I could return a tuple from
  -- a function like this:
  -- parseTerm(t1: String,pt:NNI): (pt:NNI,%)
  -- Another alternative might be to define a seperate parsing
  -- domain.
  pt:NNI :=0::NNI

  -- Constructs a reference to a bound variable from its deBruijn
  -- index
  lambda(n1:NNI): % == [[n1]]

  -- Constructs a reference to a free variable from its name
  lambda(varNme:String): % == [[varNme]]

  -- Constructs a node containing multiple terms
  lambda(x:%,y:%): % == [[x,y]]

  -- Constructs lambda term
  lambda(x:%,t1: String): % == [[x,t1]]

  parseStringTerm(t1: String):String ==
    vnm:String := ""
    ch := qelt(t1,pt)
    --sayTeX$Lisp concat("st ch=",ch::String)
    while alphanumeric?(ch) repeat
      vnm := concat(vnm,ch)     
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then return vnm
      ch := qelt(t1,pt)
    vnm

  parseFreeTerm(t1: String):% ==
    lambda(parseStringTerm(t1))

  parseLambdaTerm(t1: String):% ==
    ch := qelt(t1,pt)
    if not (ch = char("\")) then 
      error "lambda term must start with \"
      return [[0::NNI]]
    pt := pt + (1::NNI)
    if pt > maxIndex(t1) then
      error "lambda term not complete"
      return [[0::NNI]]
    str := parseStringTerm(t1)
    ch := qelt(t1,pt)
    if not (ch = char(".")) then 
      error "lambda term must have ."
      return [[0::NNI]]
    pt := pt + (1::NNI)
    if pt > maxIndex(t1) then
      error "lambda term must contain something"
      return [[0::NNI]]
    lambda(parseTerm(t1),str)

  parseBracketTerm(t1: String):% ==
    ch := qelt(t1,pt)
    if not (ch = char("(")) then 
      error "bracket term must start with ("
      return [[0::NNI]]
    pt := pt + (1::NNI)
    if pt > maxIndex(t1) then
      error "opening but no closing bracket"
      return [[0::NNI]]
    trm := parseTerm(t1)
    ch := qelt(t1,pt)
    if not (ch = char(")")) then 
      error "can't find closing bracket"
      return [[0::NNI]]
    pt := pt + (1::NNI)
    trm

  parseVariableTerm(t1: String):% ==
    inx:NNI := 0 -- holds De Bruijn index while its being read
    ch := qelt(t1,pt)
    --sayTeX$Lisp concat("pv ch=",ch::String)
    while digit?(ch) repeat
      if ch = char("0") then inx := inx*10
      if ch = char("1") then inx := inx*10 + 1
      if ch = char("2") then inx := inx*10 + 2
      if ch = char("3") then inx := inx*10 + 3
      if ch = char("4") then inx := inx*10 + 4
      if ch = char("5") then inx := inx*10 + 5
      if ch = char("6") then inx := inx*10 + 6
      if ch = char("7") then inx := inx*10 + 7
      if ch = char("8") then inx := inx*10 + 8
      if ch = char("9") then inx := inx*10 + 9
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then return lambda(inx)
      ch := qelt(t1,pt)
    lambda(inx)

  parseTerm(t1: String):% ==
    res:% := [[0::NNI]]
    ch := qelt(t1,pt)
    --sayTeX$Lisp concat("pt ch=",ch::String)
    -- first remove leading spaces
    while ch = char(" ") repeat
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then return res
      ch := qelt(t1,pt)
    if ch = char("\") then res := parseLambdaTerm(t1)
    if ch = char("(") then res := parseBracketTerm(t1)
    if digit?(ch) then res := parseVariableTerm(t1)
    if alphabetic?(ch) then res := parseFreeTerm(t1)
    -- now check for compound term
    if pt > maxIndex(t1) then return res
    ch := qelt(t1,pt)
    if ch = char(" ") then
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then return res
      res := lambda(res,parseTerm(t1))
    res

  -- Constructs nested lambda terms from a string
  -- notation assumes format like this:
  -- <term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"
  -- where:
  -- \ = lambda (I would like to use unicode lambda symbol but
  --             I would also like to keep maximum compatibility
  --             with non-unicode versions of Lisp)
  -- n = De Bruijn index which is a integer where, 1=inside inner
  --             lambda term, 2= next outer lambda term, 3= next
  --             outer and so on.
  -- brackets can be used around whole terms.
  -- This requires the user to work out the De Bruijn index values
  -- perhaps this could be improved later.
  parseLambda(t1: String): % ==
    pt := minIndex(t1)::NNI
    parseTerm(t1)

  -- returns true if this is an atom, that is free or bound variable
  -- otherwise return false if this is a compound or lambda definition
  atom?(n: %):Boolean == (n case boundTerm) or (n case freeTerm)

  -- returns true if this is a compound term containing two nodes
  isCompound?(n: %):Boolean == (n case compoundTerm)

  -- returns true if this is a lambda definition
  isLambda?(n: %):Boolean == (n case lambdaTerm)

  -- return string representation
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  -- boundTerm:Record(deBruijn:NNI, ck:NNI),
  -- freeTerm:Record(varName:String),_
  -- compoundTerm:Record(c1:%, c2:%),
  -- lambdaTerm:Record(c3:%, nm:String)
  toString(n:%):String ==
    s:String := ""
    if n case boundTerm then
      s := string(n.boundTerm.deBruijn)
      --sayTeX$Lisp s
    if n case freeTerm then
      s := n.freeTerm.varName
    if n case compoundTerm then
      s := concat(["(",toString(n.compoundTerm.c1)," ",toString(n.compoundTerm.c2),")"])
    if n case lambdaTerm then
      -- variable node so print name
      -- s := n.vr.s1
      s := concat(["(\",n.lambdaTerm.nm,".",toString(n.lambdaTerm.c3),")"])
    s

  -- substitution of 'a' for 'b' in 'n'
  subst(n: %,a: %,b: %):% ==
    if n = b then return a
    if (n case compoundTerm) then
      return lambda(subst(n.compoundTerm.c1,a,b),subst(n.compoundTerm.c2,a,b))
    if (n case lambdaTerm) then
      return lambda(subst(n.lambdaTerm.c3,a,b),n.lambdaTerm.nm)
    n

  -- beta reduction - apply beta reduction recusivly to all subnodes
  redux(n: %):% ==
    if atom?(n) then return n -- atom cant be reduced
    if n case compoundTerm then
      -- we are looking for a compound term where the first term is
      -- a lambda expression being applied to the second term.
      term1:% := n.compoundTerm.c1
      term2:% := n.compoundTerm.c2
      if isLambda?(term1) then
        -- apply term1 to term2
        boundVarName:String := term1.lambdaTerm.nm
        return subst(term1,term2,lambda(0::NNI))
      return lambda(redux(term1),redux(term2))
    if n case lambdaTerm then
      return lambda(redux(n.lambdaTerm.c3),n.lambdaTerm.nm)
    n

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be alpha-equivalent to return true
  -- That is the names, but not the deBruijn index, of the
  -- bound variables can be different.
  x = y ==
    if (x case boundTerm) and (y case boundTerm) then
      -- boundTerm so compare deBruijn index
      if x.boundTerm.deBruijn = y.boundTerm.deBruijn then return true
      return false
    if (x case freeTerm) and (y case freeTerm) then
      -- freeTerm so compare name String
      if x.freeTerm.varName = y.freeTerm.varName then return true
      return false
    if (x case compoundTerm) and (y case compoundTerm) then
      -- compoundTerm so compare both terms
      if (x.compoundTerm.c1 = y.compoundTerm.c1) and_
         (x.compoundTerm.c2 = y.compoundTerm.c2) then return true
      return false
    if (x case lambdaTerm) and (y case lambdaTerm) then
      -- lambdaTerm only compare body not variable name
      if x.lambdaTerm.c3 = y.lambdaTerm.c3 then return true
      return false
    false

  -- output
  coerce(n: %):OutputForm ==
    toString(n)::OutputForm
@
\section{SKI Combinators}
for more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/

Ski combinators were introduced by Moses Schönfinkel and Haskell
Curry with the aim of eliminating the need for variables in
mathematical logic. It is equivalent to lambda calculus but it
can be used for doing, without variables, anything that would
require variables in other systems.

The structure is a self-modifing binary tree.
\section{Tutorial}
Tutorial

The Ski domain needs to be installed on your system. Download and
compile in the usual way. Make sure it is exposed since
Axiom/FriCAS was started.

)library SKI
 
   Ski is now explicitly exposed in frame frame1 
   Ski will be automatically loaded when needed from 
      /home/martin/SKI.NRLIB/SKI

\section{Constructing SKI combinators}
Constructing SKI combinators

The I, K and S combinators can be constructed by using the I(), K()
and S() functions. Variables (representing functions) can be
constructed by ski("x") where x is the name of the variable.

(1) -> m1 := I()
   (1)  "I"
                                                              Type: Ski
(2) -> m2 := K()
   (2)  "K"
                                                              Type: Ski
(3) -> m3 := S()
   (3)  "S"
                                                              Type: Ski
(4) -> v1 := ski("x")
   (4)  "x"
                                                              Type: Ski

Compound combinators can be constructed by ski(node1,node2) where
node1 and node2 are other combinators. Internally combinators are
stored as a binary tree. The notation assumes association to the
left, in the absence of brackets, the term to the left binds more
tightly than the one on the right. So, in the following, we can
see that:

    * In n2 the second term is an atom so brackets are not required.
    * In n3 the second term is compound so brackets are required.

(5) -> n1 := ski(m1,m2)
   (5)  "IK"
                                                              Type: Ski
(6) -> n2 := ski(n1,m3)
   (6)  "IKS"
                                                              Type: Ski
(7) -> n3 := ski(m3,n1)
   (7)  "S(IK)"
                                                              Type: Ski

In addition, to avoid having to build up this node by node, there is
a quicker way to construct SKI combinators. We can construct the whole
binary tree from a single string using the parseSki constructor as
follows. Again the notation assumes association to the left, in the
absence of brackets, the term to the left binds more tightly than
the one on the right.

(8) -> n4 := parseSki("IKS")
   (8)  "IKS"
                                                              Type: Ski
(9) -> n5 := parseSki("S(IK)")
   (9)  "S(IK)"
                                                              Type: Ski
\section{redux}
redux

Now that we have constructed our SKI combinator we can apply the
combinators using the redux function. This allows us to apply the
self-modifing binary tree.

The first combinator to investigate is 'I'. This is a do nothing combinator:

(10) -> s1 := parseSki("Ix")
   (10)  "Ix"
                                                              Type: Ski
(11) -> redux(s1)
x
   (11)  "x"
                                                              Type: Ski

The next combinator to investigate is 'K'. This removes the final variable:

(12) -> s2 := parseSki("Kxy")
   (12)  "Kxy"
                                                              Type: Ski
(13) -> redux(s2)
x
   (13)  "x"
                                                              Type: Ski

The next combinator to investigate is 'S' This applies the first two
functions to the third:

(14) -> s3 := parseSki("Sxyz")
   (14)  "Sxyz"
                                                              Type: Ski
(15) -> redux(s3)
xz(yz)
   (15)  "xz(yz)"
                                                              Type: Ski
\section{Secondary Combinators}
Secondary Combinators

Any calculation can be done by some combination of K and S. However some
sequences occur frequently so it is worth assigning them special letters:

Operator 	What it does 	SKI equivalent
(normal form)
I 	Identity (leave unchanged) 	I or SKK or SKS
B 	Function composition 	S(KS)K
B' 	Reverse function composition 	 
C 	Swap functions 	S(K(SI))K
K 	Form constant function 	K
S 	Generalized composition 	S
W 	Doubling or diagonalizing 	 

So we can see in the 3 examples below :

    * In 16 that "SKKxy" is equivalent to "xy", that is SKK is identity,
      equivalent to I
    * In 18 that "S(K(SI))Kxy" is equivalent to "yx", so "S(K(SI))K"
      reverses its operands.

(16) -> redux(parseSki("SKKxy"))
Kx(Kx)y
xy
   (16)  "xy"
                                                              Type: Ski
(17) -> redux(parseSki("S(KS)xy"))
KSy(xy)
S(xy)
   (17)  "S(xy)"
                                                              Type: Ski
(18) -> redux(parseSki("S(K(SI))Kxy"))
K(SI)x(Kx)y
Iy(Kxy)
yx
   (18)  "yx"
                                                              Type: Ski
\section{To Do}
Issue 1

Currently this only works with variables, this means that:

    * redux applied to 'SKKxy' gives 'xy'
    * but redux applied to 'SKK' does not give 'I'

That is, I am looking for a way to 'lift' from working in terms
operators acting on variables to working in terms of operators only.

Issue 2

It would be good to be able to use these combinators to operate on
Axiom/FriCAS functions.


<<domain SKI Ski>>=
)abbrev domain SKI Ski
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: March 2011
++ Basic Operations: 
++ Related Constructors: 
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/ski/

Ski(): Exports == Implementation where

 NNI==> NonNegativeInteger

 Exports == with
  ski:(x:%,y:%) -> %
    ++ Constructs a node combinator over combinators
  ski:(x:%,y:Variable(I)) -> %
    ++ Constructs a node over (node,I)
  ski:(x:%,y:Variable(K)) -> %
    ++ Constructs a node over (node,K)
  ski:(x:%,y:Variable(S)) -> %
    ++ Constructs a node over (node,S)
  ski:(x:Variable(I),y:%) -> %
    ++ Constructs a node over (I,node)
  ski:(x:Variable(K),y:%) -> %
    ++ Constructs a node over (K,node)
  ski:(x:Variable(S),y:%) -> %
    ++ Constructs a node over (S,node)
  ski:(x:Variable(I),y:Variable(I)) -> %
    ++ Constructs a II combinator
  ski:(x:Variable(I),y:Variable(K)) -> %
    ++ Constructs a IK combinator
  ski:(x:Variable(I),y:Variable(S)) -> %
    ++ Constructs a IS combinator
  ski:(x:Variable(K),y:Variable(I)) -> %
    ++ Constructs a KI combinator
  ski:(x:Variable(K),y:Variable(K)) -> %
    ++ Constructs a KK combinator
  ski:(x:Variable(K),y:Variable(S)) -> %
    ++ Constructs a KS combinator
  ski:(x:Variable(S),y:Variable(I)) -> %
    ++ Constructs a SI combinator
  ski:(x:Variable(S),y:Variable(K)) -> %
    ++ Constructs a SK combinator
  ski:(x:Variable(S),y:Variable(S)) -> %
    ++ Constructs a SS combinator
  ski:(t1: String) -> %
    ++ Constructs variable combinator
  I:() -> %
    ++ Constructs a I combinator
  K:() -> %
    ++ Constructs a K combinator
  S:() -> %
    ++ Constructs a S combinator
  parseSki:(t1: String) -> %
    ++ Constructs combinators from a string
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  isI?:(n: %) -> Boolean
    ++ returns true if this is an I combinator node
  isK?:(n: %) -> Boolean
    ++ returns true if this is a K combinator node
  isS?:(n: %) -> Boolean
    ++ returns true if this is a S combinator node
  redux:(n: %) -> %
    ++ weak reduction - apply this combinator to rearange its
    ++ subnodes then apply recusivly to its subnodes
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be equal to return true
    ++ all terms must be exactly equal, not just equivalent, that is
    ++ SKK=I will return false even though 'SKK' and 'I' have the
    ++ same effect
  toString: (n: %) -> String
    ++ output
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         lf:Record(typ:NNI),_
         nd:Record(c1:%, c2:%),_
         vr:Record(s1:String)_
         )

  -- Constructs a node combinator over another combinators
  ski(x:%,y:%): % == [[x,y]]

  -- Constructs a node over (node,I)
  ski(x:%,y:Variable(I)): % == [[x,I()]]

  -- Constructs a node over (node,K)
  ski(x:%,y:Variable(K)): % == [[x,K()]]

  -- Constructs a node over (node,S)
  ski(x:%,y:Variable(S)): % == [[x,S()]]

  -- Constructs a node over (node,I)
  ski(x:Variable(I),y:%): % == [[I(),y]]

  -- Constructs a node over (node,K)
  ski(x:Variable(K),y:%): % == [[K(),y]]

  -- Constructs a node over (node,S)
  ski(x:Variable(S),y:%): % == [[S(),y]]

  -- Constructs a II combinator
  ski(x:Variable(I),y:Variable(I)): % == [[I(),I()]]

  -- Constructs a IK combinator
  ski(x:Variable(I),y:Variable(K)): % == [[I(),K()]]

  -- Constructs a IS combinator
  ski(x:Variable(I),y:Variable(S)): % == [[I(),S()]]

  -- Constructs a KI combinator
  ski(x:Variable(K),y:Variable(I)): % == [[K(),I()]]

  -- Constructs a KK combinator
  ski(x:Variable(K),y:Variable(K)): % == [[K(),K()]]

  -- Constructs a KS combinator
  ski(x:Variable(K),y:Variable(S)): % == [[K(),S()]]

  -- Constructs a SI combinator
  ski(x:Variable(S),y:Variable(I)): % == [[S(),I()]]

  -- Constructs a SK combinator
  ski(x:Variable(S),y:Variable(K)): % == [[S(),K()]]

  -- Constructs a SS combinator
  ski(x:Variable(S),y:Variable(S)): % == [[S(),S()]]

  -- Constructs variable combinator
  ski(t1: String):% ==
    [[t1]]

  -- Constructs a I combinator
  I(): % == [[1::NNI]]

  -- Constructs a K combinator
  K(): % == [[2::NNI]]

  -- Constructs a S combinator
  S(): % == [[3::NNI]]

  -- convert BinaryTree Character node to Ski node
  -- called recursivly on subnodes
  -- used by parseSki
  btc2Ski(btc: BinaryTree Character): % ==
    if leaf?(btc) then
      ch:Character := value(btc)
      if ch = char("I") then
        return [[1::NNI]]
      if ch = char("K") then
        return [[2::NNI]]
      if ch = char("S") then
        return [[3::NNI]]
      return [[ch::String]]
    if not leaf?(btc) then
      return ski(btc2Ski(left(btc)),btc2Ski(right(btc)))
    [[1::NNI]]

  -- Constructs combinators from a string
  -- ski pass required to use ski lift
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  parseSki(t1: String): % ==
    -- first we build chBuffer which holds the characters
    -- from the String and puts them in a tree
    branchStack: Stack BinaryTree Character := empty()
    chBuffer: BinaryTree Character := empty()
    mn := minIndex(t1)
    mx := maxIndex(t1)
    for pt in mn..mx repeat
      ch := qelt(t1,pt)
      if alphanumeric?(ch) then
        if empty?(chBuffer)
          then chBuffer:=binaryTree(ch)
          else chBuffer:=binaryTree(chBuffer,ch,binaryTree(ch))
      if ch = char("(") then
        push!(chBuffer,branchStack)
        chBuffer:= empty()
      if ch = char(")") then
        hold:BinaryTree Character := pop!(branchStack)
        -- if empty?(hold) then sayTeX$Lisp "hold empty"
        -- if empty?(chBuffer) then sayTeX$Lisp "chBuffer empty"
        if empty?(chBuffer)
          then
            chBuffer:=hold
            sayTeX$Lisp "chBuffer empty"
          else
            if not empty?(hold) then
              chBuffer:=binaryTree(hold,ch,chBuffer)
            --sayTeX$Lisp "chbuffer not empty"
    -- sayTeX$Lisp (mathObject2String$Lisp chBuffer)@String
    -- now chBuffer tree is built we can convert this into the ski
    -- structure
    btc2Ski(chBuffer)

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n: %):Boolean == (n case lf) or (n case vr)

  -- returns true if this is an I combinator node
  isI?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf.typ = 1 then return true
    false

  -- returns true if this is a K combinator node
  isK?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf.typ = 2 then return true
    false

  -- returns true if this is a S combinator node
  isS?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf.typ = 3 then return true
    false

  -- return string representation
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  toString(n: %):String ==
    s:String := ""
    if n case lf then
      -- leaf node so print I,K or S
      if n.lf.typ = 1 then s := "I"
      if n.lf.typ = 2 then s := "K"
      if n.lf.typ = 3 then s := "S"
      --sayTeX$Lisp concat(["toString case i1=",s])
      --sayTeX$Lisp n
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      if atom?(n.nd.c2) then
        s := concat([s,toString(n.nd.c1),toString(n.nd.c2)])
      else
        s := concat([s,toString(n.nd.c1),"(",toString(n.nd.c2),")"])
    if n case vr then
      -- variable node so print name
      s := n.vr.s1
    s

  -- weak reduction - apply this combinator to rearange its
  -- subnodes then apply recusivly to its subnodes
  redux1(n: %):% ==
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      left := redux1(n.nd.c1)
      right := redux1(n.nd.c2)
      --sayTeX$Lisp concat(["left=",toString(left),_
      --                    " right=",toString(right)])$String
      if isI?(left) then return right
      if not (left case nd) then return ski(left,right)
      leftleft := left.nd.c1
      leftright := left.nd.c2
      --sayTeX$Lisp concat(["leftleft=",toString(leftleft),_
      --                    " leftright=",toString(leftright)])$String
      if isK?(leftleft) then return leftright
      if not (leftleft case nd) then return ski(left,right)
      leftleftleft := leftleft.nd.c1
      leftleftright := leftleft.nd.c2
      --sayTeX$Lisp concat(["leftleftleft=",toString(leftleftleft),_
      --                    " leftleftright=",toString(leftleftright)])$String
      if isS?(leftleftleft) then
        return ski(ski(leftleftright,right),ski(leftright,right))
      return ski(left,right)
    n

  -- weak reduction - apply this combinator to rearange its
  -- subnodes then apply recusivly to its subnodes
  redux(n: %):% ==
    lastResult := [[1::NNI]]
    thisResult := redux1(n)
    triesLeft:NNI := 20::NNI -- limit tries in case of loop
    while (lastResult ~= thisResult) and (triesLeft > (1::NNI)) repeat
      lastResult := thisResult
      thisResult := redux1(lastResult)
      triesLeft := (triesLeft - 1)::NNI
      sayTeX$Lisp toString(lastResult)
    thisResult

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be equal to return true
  -- all terms must be exactly equal, not just equivalent, that is
  -- SKK=I will return false even though 'SKK' and 'I' have the
  -- same effect
  x = y ==
    if (x case lf) and (y case lf) then
      -- leaf node so compare I,K or S
      if x.lf.typ = y.lf.typ then return true
      return false
    if (x case vr) and (y case vr) then
      -- variable node so compare names
      if x.vr.s1 = y.vr.s1 then return true
      return false
    if (x case nd) and (y case nd) then
      -- binary node which has two subnodes c1 and c2
      if (x.nd.c1 = y.nd.c1) and (x.nd.c2 = y.nd.c2) then return true
      return false
    false

  -- output
  coerce(n: %):OutputForm ==
    toString(n)::OutputForm
@

\section{License}
<<license>>=
--Copyright (c) 2011, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>
@
\eject
\begin{thebibliography}{99}
For more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/
Tutorial for lambda calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
Tutorial for SKI calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
\end{thebibliography}
\end{document}
